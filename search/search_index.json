{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>GraphQL service for ibis dataframes, arrow tables, and parquet datasets. The schema for a query API is derived automatically.</p>"},{"location":"#version-2","title":"Version 2","text":"<p>When this project started, there was no out-of-core execution engine with performance comparable to PyArrow. So it effectively included one, based on datasets and Acero.</p> <p>Since then the ecosystem has grown considerably: DuckDB, DataFusion, and Ibis. As of version 2, graphique is based on <code>ibis</code>. It provides a common dataframe API for multiple backends, enabling graphique to also have a default but configurable backend.</p> <p>Being a major version upgrade, there are incompatible changes from version 1. However the overall API remains largely the same.</p>"},{"location":"#usage","title":"Usage","text":"<p>There is an example app which reads a parquet dataset.</p> <pre><code>env PARQUET_PATH=... uvicorn graphique.service:app\n</code></pre> <p>Open http://localhost:8000/ to try out the API in GraphiQL. There is a test fixture at <code>./tests/fixtures/zipcodes.parquet</code>.</p> <pre><code>env PARQUET_PATH=... strawberry export-schema graphique.service:app.schema\n</code></pre> <p>outputs the graphql schema.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The example app uses Starlette's config: in environment variables or a <code>.env</code> file.</p> <ul> <li>PARQUET_PATH: path to the parquet directory or file</li> <li>FEDERATED = '': field name to extend type <code>Query</code> with a federated <code>Table</code></li> <li>METRICS = False: include timings from apollo tracing extension</li> <li>COLUMNS = None: list of names, or mapping of aliases, of columns to select</li> <li>FILTERS = None: json <code>filter</code> query for which rows to read at startup</li> </ul> <p>Configuration options exist to provide a convenient no-code solution, but are subject to change in the future. Using a custom app is recommended for production usage.</p>"},{"location":"#app","title":"App","text":"<p>For more options create a custom ASGI app. Call graphique's <code>GraphQL</code> on an ibis Table or arrow Dataset. Supply a mapping of names to datasets for multiple roots, and to enable federation.</p> <pre><code>import ibis\nfrom graphique import GraphQL\n\nsource = ibis.read_*(...)  # or ibis.connect(...).table(...) or pyarrow.dataset.dataset(...)\n# apply initial projections or filters to `source`\napp = GraphQL(source)  # Table is root query type\napp = GraphQL.federated({&lt;name&gt;: source, ...}, keys={&lt;name&gt;: [], ...})  # Tables on federated fields\n</code></pre> <p>Start like any ASGI app.</p> <pre><code>uvicorn &lt;module&gt;:app\n</code></pre>"},{"location":"#api","title":"API","text":""},{"location":"#types","title":"types","text":"<ul> <li><code>Dataset</code>: interface for an ibis table or arrow dataset.</li> <li><code>Table</code>: implements the <code>Dataset</code> interface. Adds typed <code>row</code>, <code>columns</code>, and <code>filter</code> fields from introspecting the schema.</li> <li><code>Column</code>: interface for an ibis column. Each data type has a corresponding column implementation: Boolean, Int, BigInt, Float, Decimal, Date, Datetime, Time, Duration, Base64, String, Array, Struct. All columns have a <code>values</code> field for their list of scalars. Additional fields vary by type.</li> <li><code>Row</code>: scalar fields. Tables are column-oriented, and graphique encourages that usage for performance. A single <code>row</code> field is provided for convenience, but a field for a list of rows is not. Requesting parallel columns is far more efficient.</li> </ul>"},{"location":"#selection","title":"selection","text":"<ul> <li><code>slice</code>: contiguous selection of rows</li> <li><code>filter</code>: select rows by predicates</li> <li><code>join</code>: join tables by key columns</li> <li><code>take</code>: rows by index</li> <li><code>dropNull</code>: remove rows with nulls</li> </ul>"},{"location":"#projection","title":"projection","text":"<ul> <li><code>project</code>: project columns with expressions</li> <li><code>columns</code>: provides a field for every <code>Column</code> in the schema</li> <li><code>column</code>: access a column of any type by name</li> <li><code>row</code>: provides a field for each scalar of a single row</li> <li><code>cast</code>: cast column types</li> <li><code>fillNull</code>: fill null values</li> </ul>"},{"location":"#aggregation","title":"aggregation","text":"<ul> <li><code>group</code>: group by given columns, and aggregate the others</li> <li><code>distinct</code>: group with all columns</li> <li><code>runs</code>: provisionally group by adjacency</li> <li><code>unnest</code>: unnest an array column</li> <li><code>count</code>: number of rows</li> </ul>"},{"location":"#ordering","title":"ordering","text":"<ul> <li><code>order</code>: sort table by given columns</li> <li>options <code>limit</code> and <code>dense</code>: select rows with smallest or largest values</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Performance is dependent on the ibis backend, which defaults to duckdb. There are no internal Python loops. Scalars do not become Python types until serialized.</p> <p>PyArrow is also used for partitioned dataset optimizations, and for any feature which ibis does not support. Table fields are lazily evaluated up until scalars are reached, and automatically cached as needed for multiple fields.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install graphique[server]\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>ibis-framework (with duckdb or other backend)</li> <li>strawberry-graphql[asgi,cli]</li> <li>pyarrow</li> <li>isodate</li> <li>uvicorn (or other ASGI server)</li> </ul>"},{"location":"#tests","title":"Tests","text":"<p>100% branch coverage.</p> <pre><code>pytest [--cov]\n</code></pre>"},{"location":"api/","title":"GraphQL API","text":""},{"location":"api/#types","title":"Types","text":"<p>A typed schema is automatically generated from the table and its columns. However, advanced usage of tables often creates new columns - or changes the type of existing ones - and therefore falls outside the schema. Fields which create columns also allow aliasing, otherwise the column is replaced.</p>"},{"location":"api/#output","title":"Output","text":"<p>A column within the schema can be accessed by <code>Table.columns</code>.</p> <pre><code>{\n    columns {\n        &lt;name&gt; { ... }\n    }\n}\n</code></pre> <p>Any column can be accessed by name using <code>Dataset.column</code> and inline fragments.</p> <pre><code>{\n    column(name: \"...\") {\n        ... on &lt;Type&gt;Column { ... }\n    }\n}\n</code></pre>"},{"location":"api/#input","title":"Input","text":"<p>Input types don't have the equivalent of inline fragments, but GraphQL is converging on the OneOf input pattern. Effectively the type of the field becomes the name of the field.</p> <p><code>Table.filter</code> provides simple queries for columns within the schema, and a <code>where</code> arguments for complex expressions.</p> <pre><code>{\n    filter(&lt;name&gt;: { ... }, ..., where: { ... })  { ... }\n}\n</code></pre> <p><code>Table.project</code> also supports complex expressions with aliased column names.</p> <pre><code>{\n    project(columns: [{ ... }])  { ... }\n}\n</code></pre> <p>Note list inputs allow passing a single value, coercing the input to a list of 1.</p> <p>The versatility of expressions can become complicated and unreadable. Consider applying expected projections to the root at startup, making <code>filter</code> and <code>project</code> simpler without performance penalty. Fields are not automatically camel-cased for the same reason; it's simpler to project first.</p>"},{"location":"api/#partitions","title":"Partitions","text":"<p>Partitioned parquet datasets have custom optimization for fragment keys.</p> <ul> <li><code>filter</code> on fragment keys</li> <li><code>group</code> on fragment keys with counts</li> <li><code>order</code> with limit on fragment keys</li> </ul> <p>Otherwise there is no advantage in the root being an arrow dataset over an ibis table.</p>"},{"location":"api/#roots","title":"Roots","text":"<p>A single root can be attached directly. This is not common - but perfectly valid - GraphQL usage. The resolvers receive the table object as the first argument, just as with nested fields.</p> <p>Alternatively multiple named roots can be attached. This also enables federation, which can be ignored if not needed. Optionally keys can also be specified, which are translated into matching equality queries.</p> <p><code>IntColumn.takeFrom</code> enables using one table as an index into another. Whether there is a performance benefit over <code>filter</code> will of course vary by backend, but there is potential to be orders of magnitude faster than a scan.</p>"},{"location":"api/#column-selection","title":"Column selection","text":"<p>Each field resolver transforms a table or column as needed. Ibis is lazily executed, so there is no <code>select</code> field because it's handled automatically. Conversely if multiple table fields are requested, the table selection is cached for performance and consistency.</p>"},{"location":"api/#arrays","title":"Arrays","text":"<p>Ibis Array columns are supported. <code>unnest</code> flattens arrays back to scalars, and <code>group: {aggregate: {collect: ...}}</code> also creates arrays.</p>"},{"location":"api/#nulls","title":"Nulls","text":"<p>GraphQL continues the long tradition of confusing \"optional\" with \"nullable\". Graphique strives to be explicit regarding what may be omitted versus what may be null.</p>"},{"location":"api/#output_1","title":"Output","text":"<p>Ibis has first-class support for nulls, so array scalars are nullable. Non-null scalars are used where relevant.</p> <p>Columns and rows are nullable to allow partial query results. <code>Dataset.optional</code> enables client controlled nullability.</p>"},{"location":"api/#input_1","title":"Input","text":"<p>Default values and non-null types are used wherever possible. When an input is optional and has no natural default, there are two cases to distinguish:</p> <ul> <li>if null is expected and semantically different, the input's description explains null behavior</li> <li>otherwise the input has an <code>@optional</code> directive, and explicit null behavior is undefined</li> </ul>"},{"location":"api/#extending","title":"Extending","text":"<p>The <code>Dataset</code> interface can subclassed to add fields, making a custom strawberry asgi app.</p> <pre><code>from graphique import Dataset\n\n@strawberry.type\nclass NewType(Dataset):\n    __init__ = Dataset.__init__\n\n    @strawberry.field\n    def new_field(self) -&gt; T:\n        self.table # the underlying ibis table\n</code></pre>"},{"location":"examples/","title":"Example Queries","text":"In\u00a0[1]: Copied! <pre>import ibis\nfrom strawberry.utils.str_converters import to_camel_case\n\nfrom graphique import GraphQL\n\n\ndef execute(query):\n    result = app.schema.execute_sync(query, root_value=app.root_value)\n    for error in result.errors or []:\n        raise ValueError(error)\n    return result.data\n\n\ntable = ibis.read_parquet('../tests/fixtures/zipcodes.parquet')\n# example projection: camel-cased fields (not relevant in this dataset)\n_ = table.select({to_camel_case(name): table[name] for name in table.columns})\napp = GraphQL(table)\n</pre> import ibis from strawberry.utils.str_converters import to_camel_case  from graphique import GraphQL   def execute(query):     result = app.schema.execute_sync(query, root_value=app.root_value)     for error in result.errors or []:         raise ValueError(error)     return result.data   table = ibis.read_parquet('../tests/fixtures/zipcodes.parquet') # example projection: camel-cased fields (not relevant in this dataset) _ = table.select({to_camel_case(name): table[name] for name in table.columns}) app = GraphQL(table) In\u00a0[2]: Copied! <pre>execute(\"\"\"{\n  count\n  schema {\n    names\n    types\n    partitioning\n  }\n}\"\"\")\n</pre> execute(\"\"\"{   count   schema {     names     types     partitioning   } }\"\"\") Out[2]: <pre>{'count': 41700,\n 'schema': {'names': ['latitude',\n   'longitude',\n   'state',\n   'city',\n   'county',\n   'zipcode'],\n  'types': ['float64', 'float64', 'string', 'string', 'string', 'int32'],\n  'partitioning': []}}</pre> In\u00a0[3]: Copied! <pre>execute(\"\"\"{\n  filter(state: {eq: \"CA\"}) {\n    group(by: \"county\", aggregate: {collect: {name: \"city\", distinct: true}}) {\n\t  project(columns: {alias: \"cities\", array: {length: {name: \"city\"}}}) {\n        order(by: \"-cities\", limit: 5) {\n          columns {\n            county {\n              values\n            }\n          }\n          cities: column(name: \"cities\") {\n            ... on BigIntColumn {\n              values\n            }\n          }\n        }\n      }\n    }\n  }\n}\"\"\")\n</pre> execute(\"\"\"{   filter(state: {eq: \"CA\"}) {     group(by: \"county\", aggregate: {collect: {name: \"city\", distinct: true}}) { \t  project(columns: {alias: \"cities\", array: {length: {name: \"city\"}}}) {         order(by: \"-cities\", limit: 5) {           columns {             county {               values             }           }           cities: column(name: \"cities\") {             ... on BigIntColumn {               values             }           }         }       }     }   } }\"\"\") Out[3]: <pre>{'filter': {'group': {'project': {'order': {'columns': {'county': {'values': ['Los Angeles',\n        'San Bernardino',\n        'San Diego',\n        'Orange',\n        'Riverside']}},\n     'cities': {'values': [132, 73, 52, 47, 42]}}}}}}</pre> In\u00a0[4]: Copied! <pre>execute(\"\"\"{\n  filter(where: {eq: [{name: \"county\"}, {name: \"city\"}]}) {\n    columns {\n      state {\n        distinct {\n          values\n        }\n      }\n    }\n  }\n}\"\"\")\n</pre> execute(\"\"\"{   filter(where: {eq: [{name: \"county\"}, {name: \"city\"}]}) {     columns {       state {         distinct {           values         }       }     }   } }\"\"\") Out[4]: <pre>{'filter': {'columns': {'state': {'distinct': {'values': ['VT',\n      'WV',\n      'NC',\n      'FL',\n      'MN',\n      'KS',\n      'AR',\n      'OK',\n      'TX',\n      'ID',\n      'AK',\n      'PR',\n      'MA',\n      'RI',\n      'NH',\n      'ME',\n      'CT',\n      'MD',\n      'KY',\n      'SD',\n      'CO',\n      'UT',\n      'AZ',\n      'NV',\n      'CA',\n      'WA',\n      'VA',\n      'OH',\n      'IN',\n      'WI',\n      'MO',\n      'NE',\n      'LA',\n      'NM',\n      'HI',\n      'OR',\n      'NJ',\n      'NY',\n      'PA',\n      'DE',\n      'SC',\n      'AL',\n      'TN',\n      'MS',\n      'MI',\n      'IA',\n      'ND',\n      'MT',\n      'IL',\n      'WY']}}}}}</pre> In\u00a0[5]: Copied! <pre>execute(\"\"\"{\n  project(columns: {alias: \"match\", eq: [{name: \"county\"}, {name: \"city\"}]}) {\n    group(by: \"state\", aggregate: {any: {name: \"match\"}}) {\n      filter(where: {inv: {name: \"match\"}}) {\n        columns {\n          state {\n            values\n          }\n        }\n      }\n    }\n  }\n}\"\"\")\n</pre> execute(\"\"\"{   project(columns: {alias: \"match\", eq: [{name: \"county\"}, {name: \"city\"}]}) {     group(by: \"state\", aggregate: {any: {name: \"match\"}}) {       filter(where: {inv: {name: \"match\"}}) {         columns {           state {             values           }         }       }     }   } }\"\"\") Out[5]: <pre>{'project': {'group': {'filter': {'columns': {'state': {'values': ['DC',\n       'GA']}}}}}}</pre>"},{"location":"examples/#view-schema","title":"View schema.\u00b6","text":""},{"location":"examples/#find-california-counties-with-the-most-cities","title":"Find California counties with the most cities.\u00b6","text":"<ul> <li><code>filter</code> state by \"CA\"</li> <li><code>group</code> by county<ul> <li>aggregate distinct cities</li> </ul> </li> <li><code>project</code> city count</li> <li><code>order</code> by city counts descending</li> <li>access <code>columns</code><ul> <li><code>county</code> is still known in the schema</li> <li>cities is a new <code>column</code> accessed through an inline fragment</li> </ul> </li> </ul>"},{"location":"examples/#find-states-with-cities-which-match-the-name-of-their-county","title":"Find states with cities which match the name of their county.\u00b6","text":"<ul> <li><code>filter</code> using <code>where</code> expression, because comparing two columns is not a \"simple\" query</li> <li><code>Column.distinct</code> instead of <code>group</code>, because no other aggregates are needed</li> </ul>"},{"location":"examples/#states-which-have-no-cities-which-match-the-name-of-their-county","title":"States which have no cities which match the name of their county.\u00b6","text":"<p>The opposite of the previous example. Filtering rows would drop needed data; the \"zeros\" have to be counted.</p> <ul> <li><code>project</code> column matching names instead of filtering</li> <li><code>group</code> by state<ul> <li>aggregate whether there are <code>any</code> matches</li> </ul> </li> <li><code>filter</code> for no matches</li> <li>access column</li> </ul>"},{"location":"reference/","title":"Core Reference","text":""},{"location":"reference/#graphique.core.Parquet","title":"<code>graphique.core.Parquet</code>","text":"<p>               Bases: <code>Dataset</code></p> <p>Partitioned parquet dataset.</p> Source code in <code>graphique/core.py</code> <pre><code>class Parquet(ds.Dataset):\n    \"\"\"Partitioned parquet dataset.\"\"\"\n\n    def schema(self) -&gt; pa.Schema:\n        \"\"\"partition schema\"\"\"\n        return self.partitioning.schema if hasattr(self, 'partitioning') else pa.schema([])\n\n    def keys(self, *names) -&gt; list:\n        \"\"\"Return prefix of matching partition keys.\"\"\"\n        keys = set(Parquet.schema(self).names)\n        return list(itertools.takewhile(lambda name: name.lstrip('-') in keys, names))\n\n    def fragments(self, counts: str = '') -&gt; ibis.Table:\n        \"\"\"Return partition fragments as a table.\"\"\"\n        parts = []\n        for frag in self._get_fragments(self._scan_options.get('filter')):\n            parts.append(ds.get_partition_keys(frag.partition_expression))\n            parts[-1]['__path__'] = frag.path\n            if counts:\n                parts[-1][counts] = frag.count_rows()\n        return ibis.memtable(pa.Table.from_pylist(parts))\n\n    def group(self, *names, counts: str = '') -&gt; ibis.Table:\n        \"\"\"Return grouped partitions as a table.\"\"\"\n        table = Parquet.fragments(self, counts)\n        agg = {counts: table[counts].sum()} if counts else {}\n        return table.aggregate(agg, by=names).order_by(*names)\n\n    def filter(self, expr: ds.Expression) -&gt; ds.Dataset | None:\n        \"\"\"Attempt to apply filter to partition keys.\"\"\"\n        try:  # raises ValueError if filter references non-partition keys\n            ds.dataset([], schema=self.partitioning.schema).scanner(filter=expr)\n        except (AttributeError, ValueError):\n            return None\n        return self if expr is None else self.filter(expr)\n\n    def to_table(self) -&gt; ibis.Table:\n        \"\"\"Return ibis `Table` from filtered dataset.\"\"\"\n        paths = [frag.path for frag in self._get_fragments(self._scan_options.get('filter'))]\n        hive = isinstance(self.partitioning, ds.HivePartitioning)\n        return ibis.read_parquet(paths, hive_partitioning=hive)\n\n    def rank(self, limit: int, *names: str, dense: bool = False) -&gt; ibis.Table:\n        \"\"\"Return ordered limited partitions as a table.\"\"\"\n        keys = {name.strip('-'): order_key(name) for name in names}\n        table = Parquet.fragments(self, counts='_').order_by(*keys.values()).cache()\n        groups = table.aggregate(count=ibis._.count(), total=table['_'].sum(), by=list(keys))\n        groups = groups.order_by(*keys.values()).cache()\n        if not dense:\n            totals = itertools.accumulate(groups['total'].to_list())\n            limit = next((index for index, total in enumerate(totals, 1) if total &gt;= limit), None)  # type: ignore\n        limit = groups[:limit]['count'].sum().to_pyarrow().as_py()\n        hive = isinstance(self.partitioning, ds.HivePartitioning)\n        return ibis.read_parquet(table[:limit]['__path__'].to_list(), hive_partitioning=hive)\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.filter","title":"<code>filter(expr)</code>","text":"<p>Attempt to apply filter to partition keys.</p> Source code in <code>graphique/core.py</code> <pre><code>def filter(self, expr: ds.Expression) -&gt; ds.Dataset | None:\n    \"\"\"Attempt to apply filter to partition keys.\"\"\"\n    try:  # raises ValueError if filter references non-partition keys\n        ds.dataset([], schema=self.partitioning.schema).scanner(filter=expr)\n    except (AttributeError, ValueError):\n        return None\n    return self if expr is None else self.filter(expr)\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.fragments","title":"<code>fragments(counts='')</code>","text":"<p>Return partition fragments as a table.</p> Source code in <code>graphique/core.py</code> <pre><code>def fragments(self, counts: str = '') -&gt; ibis.Table:\n    \"\"\"Return partition fragments as a table.\"\"\"\n    parts = []\n    for frag in self._get_fragments(self._scan_options.get('filter')):\n        parts.append(ds.get_partition_keys(frag.partition_expression))\n        parts[-1]['__path__'] = frag.path\n        if counts:\n            parts[-1][counts] = frag.count_rows()\n    return ibis.memtable(pa.Table.from_pylist(parts))\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.group","title":"<code>group(*names, counts='')</code>","text":"<p>Return grouped partitions as a table.</p> Source code in <code>graphique/core.py</code> <pre><code>def group(self, *names, counts: str = '') -&gt; ibis.Table:\n    \"\"\"Return grouped partitions as a table.\"\"\"\n    table = Parquet.fragments(self, counts)\n    agg = {counts: table[counts].sum()} if counts else {}\n    return table.aggregate(agg, by=names).order_by(*names)\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.keys","title":"<code>keys(*names)</code>","text":"<p>Return prefix of matching partition keys.</p> Source code in <code>graphique/core.py</code> <pre><code>def keys(self, *names) -&gt; list:\n    \"\"\"Return prefix of matching partition keys.\"\"\"\n    keys = set(Parquet.schema(self).names)\n    return list(itertools.takewhile(lambda name: name.lstrip('-') in keys, names))\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.rank","title":"<code>rank(limit, *names, dense=False)</code>","text":"<p>Return ordered limited partitions as a table.</p> Source code in <code>graphique/core.py</code> <pre><code>def rank(self, limit: int, *names: str, dense: bool = False) -&gt; ibis.Table:\n    \"\"\"Return ordered limited partitions as a table.\"\"\"\n    keys = {name.strip('-'): order_key(name) for name in names}\n    table = Parquet.fragments(self, counts='_').order_by(*keys.values()).cache()\n    groups = table.aggregate(count=ibis._.count(), total=table['_'].sum(), by=list(keys))\n    groups = groups.order_by(*keys.values()).cache()\n    if not dense:\n        totals = itertools.accumulate(groups['total'].to_list())\n        limit = next((index for index, total in enumerate(totals, 1) if total &gt;= limit), None)  # type: ignore\n    limit = groups[:limit]['count'].sum().to_pyarrow().as_py()\n    hive = isinstance(self.partitioning, ds.HivePartitioning)\n    return ibis.read_parquet(table[:limit]['__path__'].to_list(), hive_partitioning=hive)\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.schema","title":"<code>schema()</code>","text":"<p>partition schema</p> Source code in <code>graphique/core.py</code> <pre><code>def schema(self) -&gt; pa.Schema:\n    \"\"\"partition schema\"\"\"\n    return self.partitioning.schema if hasattr(self, 'partitioning') else pa.schema([])\n</code></pre>"},{"location":"reference/#graphique.core.Parquet.to_table","title":"<code>to_table()</code>","text":"<p>Return ibis <code>Table</code> from filtered dataset.</p> Source code in <code>graphique/core.py</code> <pre><code>def to_table(self) -&gt; ibis.Table:\n    \"\"\"Return ibis `Table` from filtered dataset.\"\"\"\n    paths = [frag.path for frag in self._get_fragments(self._scan_options.get('filter'))]\n    hive = isinstance(self.partitioning, ds.HivePartitioning)\n    return ibis.read_parquet(paths, hive_partitioning=hive)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset","title":"<code>graphique.interface.Dataset</code>","text":"Source code in <code>graphique/interface.py</code> <pre><code>@strawberry.interface(description=\"ibis `Table` or arrow `Dataset`\")\nclass Dataset:\n    def __init__(self, source: Source):\n        self.source = source\n\n    @property\n    def table(self) -&gt; ibis.Table:\n        \"\"\"source as ibis table\"\"\"\n        return self.source if isinstance(self.source, ibis.Table) else Parquet.to_table(self.source)\n\n    def resolve(self, info: Info, source: ibis.Table) -&gt; Self:\n        \"\"\"Cache the table if it will be reused.\"\"\"\n        counts = selections(*info.selected_fields)\n        counts['type'] = counts['schema'] = 0\n        if counts.total() &gt; 1 and isinstance(source, ibis.Table):\n            if names := self.select(info, source):\n                source = source.select(*names).cache()\n        return type(self)(source)\n\n    @classmethod\n    @no_type_check\n    def resolve_reference(cls, info: Info, **keys) -&gt; Self:\n        \"\"\"Return table filtered by federated keys.\"\"\"\n        self = getattr(info.root_value, cls.field)\n        queries = {name: Filter(eq=[keys[name]]) for name in keys}\n        return self.filter(info, **queries)\n\n    @staticmethod\n    def select(info: Info, source: Source) -&gt; list:\n        \"\"\"Return minimal schema needed to continue.\"\"\"\n        refs: set = set()\n        for field in info.selected_fields:\n            for selection in field.selections:\n                refs.update(references(selection))\n        return [name for name in ibis_schema(source) if name in refs]\n\n    def columns(self, info: Info) -&gt; dict:\n        \"\"\"Fields for each column.\"\"\"\n        names = selections(*info.selected_fields)\n        table = self.table.select(*names).cache()\n        return {name: Column.cast(table[name]) for name in table.columns}\n\n    def row(self, info: Info, index: int = 0) -&gt; dict:\n        \"\"\"Scalar values at index.\"\"\"\n        names = selections(*info.selected_fields)\n        table = self.table.select(*names)[index:][:1].cache()\n        row = {}\n        for name in table.columns:\n            if isinstance(table[name], ibis.expr.types.ArrayColumn):\n                row[name] = Column.cast(table[name].first().unnest())\n            else:\n                (row[name],) = table[name].to_list()\n        return row\n\n    def filter(self, info: Info, where: Expression | None = None, **queries: Filter) -&gt; Self:\n        \"\"\"[Filter](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.filter) rows by predicates.\n\n        Schema derived fields provide syntax for simple queries; `where` supports complex queries.\n        \"\"\"\n        exprs: list = [] if where is None else list(where)  # type: ignore\n        source = Parquet.filter(self.source, Filter.to_arrow(**queries))\n        if source is None:\n            exprs += Filter.to_exprs(**queries)\n            source = self.table\n        elif exprs:\n            source = Parquet.to_table(source)\n        return self.resolve(info, source.filter(*exprs) if exprs else source)\n\n    @strawberry.field(\n        description=f\"[ibis table]({links.ref}/expression-table) or [arrow dataset](https://arrow.apache.org/docs/python/api/dataset.html)\"\n    )\n    def type(self) -&gt; str:\n        return type(self.source).__name__\n\n    @strawberry.field(description=links.schema)\n    def schema(self) -&gt; Schema:\n        schema = ibis_schema(self.source)\n        partitioning = Parquet.schema(self.source).names\n        return Schema(names=schema.names, types=schema.types, partitioning=partitioning)  # type: ignore\n\n    @doc_field(\n        schema=\"field names and types\",\n        try_=\"return null if cast fails\",\n    )\n    def cast(self, info: Info, schema: list[Field], try_: bool = False) -&gt; Self:\n        \"\"\"[Cast](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.cast) the columns of a table.\"\"\"\n        cast = self.table.try_cast if try_ else self.table.cast\n        return self.resolve(info, cast({field.name: field.type for field in schema}))\n\n    @doc_field\n    def optional(self, info: Info) -&gt; Self | None:\n        \"\"\"Nullable field to stop error propagation, enabling partial query results.\n\n        Will be replaced by client controlled nullability.\n        \"\"\"\n        return self.resolve(info, self.source)\n\n    @strawberry.field(\n        description=f\"[Count]({links.ref}/expression-tables#ibis.expr.types.relations.Table.count) the number of rows.\"\n    )\n    def count(self) -&gt; BigInt:\n        if isinstance(self.source, ibis.Table):\n            return self.source.count().to_pyarrow().as_py()\n        return self.source.count_rows()\n\n    @doc_field\n    def any(self, limit: BigInt = 1) -&gt; bool:\n        \"\"\"Whether there are at least `limit` rows.\n\n        May be significantly faster than `count` for out-of-core data.\n        \"\"\"\n        return self.table[:limit].count().to_pyarrow().as_py() &gt;= limit\n\n    @doc_field(\n        name=\"column name(s); multiple names access nested struct fields\",\n        cast=f\"cast expression to indicated {links.types}\",\n        try_=\"return null if cast fails\",\n    )\n    def column(self, name: list[str], cast: str = '', try_: bool = False) -&gt; Column | None:\n        \"\"\"Column of any type by name.\n\n        If the column is in the schema, `columns` can be used instead.\n        \"\"\"\n        column = getitems(self.table, *name)\n        if cast:\n            column = (column.try_cast if try_ else column.cast)(cast)\n        return Column.cast(column.as_table().cache()[0])\n\n    @doc_field(\n        offset=\"number of rows to skip; negative value skips from the end\",\n        limit=\"maximum number of rows to return\",\n    )\n    def slice(self, info: Info, offset: BigInt = 0, limit: BigInt | None = None) -&gt; Self:\n        \"\"\"[Limit](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.limit) row selection.\"\"\"\n        return self.resolve(info, self.table[offset:][:limit])\n\n    @doc_field(\n        on=\"column names to deduplicate on; defaults to all\",\n        keep=\"which duplicates to keep\",\n        counts=f\"[value counts]({links.ref}/expression-tables#ibis.expr.types.relations.Table.value_counts); incompatible with `keep: null`\",\n        order=\"optionally include and order by first row number; incompatible with `on: null`\",\n    )\n    def distinct(\n        self,\n        info: Info,\n        on: list[str] | None = None,\n        keep: str | None = 'first',\n        counts: str = '',\n        order: str = '',\n    ) -&gt; Self:\n        \"\"\"[Remove duplicate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.distinct) rows from table.\n\n        Differs from `group` by keeping all columns, and defaulting to all keys.\n        \"\"\"\n        table = self.table\n        if order:\n            table = table.mutate({order: ibis.row_number()})\n        if not counts or keep is None:\n            table = table.distinct(on=on, keep=keep)\n        elif on is None:\n            table = table.value_counts(name=counts)\n        else:\n            keys, func = set(on), operator.methodcaller(keep)\n            aggs = {name: func(table[name]) for name in table.columns if name not in keys}\n            aggs[counts] = ibis._.count()\n            table = table.aggregate(aggs, by=on)\n        return self.resolve(info, table.order_by(order) if order else table)\n\n    @doc_field(\n        by=\"column names; empty will aggregate into a single row table\",\n        counts=\"optionally include counts in an aliased column\",\n        order=\"optionally include and order by first row number\",\n        aggregate=\"aggregation functions applied to other columns\",\n    )\n    def group(\n        self,\n        info: Info,\n        by: list[str] = [],\n        counts: str = '',\n        order: str = '',\n        aggregate: Aggregates = {},  # type: ignore\n    ) -&gt; Self:\n        \"\"\"[Group](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.group_by) table by columns.\"\"\"\n        aggs = dict(aggregate)  # type: ignore\n        if not aggs and not order and by == Parquet.keys(self.source, *by):\n            return self.resolve(info, Parquet.group(self.source, *by, counts=counts))\n        table = self.table\n        if counts:\n            aggs[counts] = ibis._.count()\n        if order:\n            table = table.mutate({order: ibis.row_number()})\n            aggs[order] = table[order].first()\n        table = table.aggregate(aggs, by=by)\n        return self.resolve(info, table.order_by(order) if order else table)\n\n    @doc_field(\n        by=\"column names; prefix with `-` for descending order\",\n        limit=\"maximum number of rows to return; optimized for partitioned dataset keys\",\n        dense=\"use dense rank with `limit`\",\n    )\n    def order(\n        self, info: Info, by: list[str], limit: BigInt | None = None, dense: bool = False\n    ) -&gt; Self:\n        \"\"\"[Sort](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.order_by) table by columns.\"\"\"\n        keys = Parquet.keys(self.source, *by)\n        if keys and limit is not None:\n            table = Parquet.rank(self.source, limit, *keys, dense=dense)\n            if keys == by:\n                return self.resolve(info, table if dense else table[:limit])\n        else:\n            table = self.table\n        if dense and limit is not None:\n            groups = table.aggregate(_=ibis._.count(), by=[name.lstrip('-') for name in by])\n            limit = groups.order_by(*map(order_key, by))[:limit]['_'].sum().to_pyarrow().as_py()\n        return self.resolve(info, table.order_by(*map(order_key, by))[:limit])\n\n    @doc_field(\n        name=\"column name\",\n        offset=\"optionally include index column\",\n        keep_empty=\"keep empty array values as null\",\n        row_number=\"optionally include first row number in an aliased column\",\n    )\n    def unnest(\n        self,\n        info: Info,\n        name: str,\n        offset: str = '',\n        keep_empty: bool = False,\n        row_number: str = '',\n    ) -&gt; Self:\n        \"\"\"[Unnest](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.unnest) an array column from a table.\"\"\"\n        table = self.table\n        if row_number:\n            table = table.mutate({row_number: ibis.row_number()})\n        return self.resolve(info, table.unnest(name, offset=offset or None, keep_empty=keep_empty))\n\n    @doc_field(\n        right=\"name of right table; must be on root Query type\",\n        keys=\"column names used as keys on the left side\",\n        rkeys=\"column names used as keys on the right side; defaults to left side\",\n        how=\"the kind of join: 'inner', 'left', 'right', ...\",\n        lname=\"format string to use to rename overlapping columns in the left table\",\n        rname=\"format string to use to rename overlapping columns in the right table\",\n    )\n    def join(\n        self,\n        info: Info,\n        right: str,\n        keys: list[str],\n        rkeys: list[str] = [],\n        how: str = 'inner',\n        lname: str = '',\n        rname: str = '{name}_right',\n    ) -&gt; Self:\n        \"\"\"[Join](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.join) two tables.\"\"\"\n        left = self.table\n        right = getattr(info.root_value, right).table\n        if rkeys:\n            keys = [getattr(left, key) == getattr(right, rkey) for key, rkey in zip(keys, rkeys)]\n        return self.resolve(\n            info, left.join(right, predicates=keys, how=how, lname=lname, rname=rname)\n        )\n\n    @doc_field\n    def take(self, info: Info, indices: list[BigInt]) -&gt; Self:\n        \"\"\"[Take](https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Dataset.html#pyarrow.dataset.Dataset.take) rows by index.\"\"\"\n        names = self.select(info, self.source)\n        if isinstance(self.source, ds.Dataset):\n            table = self.source.take(indices, columns=names)\n        else:\n            batches = self.source.select(*names).to_pyarrow_batches()\n            table = ds.Scanner.from_batches(batches).take(indices)\n        return type(self)(ibis.memtable(table))\n\n    @doc_field(subset=\"columns names; defaults to all\", how=\"remove if `any` or `all` are null\")\n    def drop_null(self, info: Info, subset: list[str] | None = None, how: str = 'any') -&gt; Self:\n        \"\"\"[Drop](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.drop_null) rows with null values.\"\"\"\n        return self.resolve(info, self.table.drop_null(subset, how=how))\n\n    @doc_field(name=\"column name(s); defaults to all\", value=\"JSON scalar\", scalar=\"typed scalar\")\n    def fill_null(\n        self,\n        info: Info,\n        name: list[str] | None = None,\n        value: JSON | None = UNSET,\n        scalar: Scalars = {},  # type: ignore\n    ) -&gt; Self:\n        \"\"\"[Fill null](https://ibis-project.org/reference/expression-tables.html#ibis.expr.types.relations.Table.fill_null) values.\"\"\"\n        (value,) = itertools.chain(scalar, [] if value is UNSET else [value])  # type: ignore\n        replacements = dict.fromkeys(ibis_schema(self.source) if name is None else name, value)\n        return self.resolve(info, self.table.fill_null(replacements))\n\n    @doc_field\n    def project(self, info: Info, columns: list[Projection]) -&gt; Self:\n        \"\"\"[Mutate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.mutate) columns by expressions.\n\n        Renamed to not be confused with a mutation.\n        \"\"\"\n        projection = dict(map(Projection.to_ibis, columns))\n        return self.resolve(info, self.table.mutate(projection))\n\n    @doc_field(\n        by=\"column names to compare by equality\",\n        split=\"boolean column expressions to split on true values\",\n        counts=\"optionally include counts in an aliased column\",\n        alias=\"format string to name index columns\",\n        aggregate=\"aggregation functions applied to other columns\",\n    )\n    def runs(\n        self,\n        info: Info,\n        by: list[str] = [],\n        split: list[Projection] = [],\n        counts: str = '',\n        alias: str = '{}_index',\n        aggregate: Aggregates = {},  # type: ignore\n    ) -&gt; Self:\n        \"\"\"Provisionally group table by adjacent values in columns.\"\"\"\n        table = self.table\n        projection = dict(map(Projection.to_ibis, split))\n        for name in by:\n            column = table[name] != table[name].lag()\n            projection[alias.format(name)] = column.fill_null(False)\n        aggs = {name: ibis._[name].first() for name in by}\n        aggs.update(aggregate)  # type: ignore\n        if counts:\n            aggs[counts] = ibis._.count()\n        table = table.mutate(projection)  # window functions can't be nested\n        table = table.mutate({name: table[name].cumsum() for name in projection})\n        return self.resolve(info, table.aggregate(aggs, by=list(projection)).order_by(*projection))\n\n    runs.directives = [provisional()]\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.table","title":"<code>table</code>  <code>property</code>","text":"<p>source as ibis table</p>"},{"location":"reference/#graphique.interface.Dataset.any","title":"<code>any(limit=1)</code>","text":"<p>Whether there are at least <code>limit</code> rows.</p> <p>May be significantly faster than <code>count</code> for out-of-core data.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field\ndef any(self, limit: BigInt = 1) -&gt; bool:\n    \"\"\"Whether there are at least `limit` rows.\n\n    May be significantly faster than `count` for out-of-core data.\n    \"\"\"\n    return self.table[:limit].count().to_pyarrow().as_py() &gt;= limit\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.cast","title":"<code>cast(info, schema, try_=False)</code>","text":"<p>Cast the columns of a table.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    schema=\"field names and types\",\n    try_=\"return null if cast fails\",\n)\ndef cast(self, info: Info, schema: list[Field], try_: bool = False) -&gt; Self:\n    \"\"\"[Cast](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.cast) the columns of a table.\"\"\"\n    cast = self.table.try_cast if try_ else self.table.cast\n    return self.resolve(info, cast({field.name: field.type for field in schema}))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.column","title":"<code>column(name, cast='', try_=False)</code>","text":"<p>Column of any type by name.</p> <p>If the column is in the schema, <code>columns</code> can be used instead.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    name=\"column name(s); multiple names access nested struct fields\",\n    cast=f\"cast expression to indicated {links.types}\",\n    try_=\"return null if cast fails\",\n)\ndef column(self, name: list[str], cast: str = '', try_: bool = False) -&gt; Column | None:\n    \"\"\"Column of any type by name.\n\n    If the column is in the schema, `columns` can be used instead.\n    \"\"\"\n    column = getitems(self.table, *name)\n    if cast:\n        column = (column.try_cast if try_ else column.cast)(cast)\n    return Column.cast(column.as_table().cache()[0])\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.columns","title":"<code>columns(info)</code>","text":"<p>Fields for each column.</p> Source code in <code>graphique/interface.py</code> <pre><code>def columns(self, info: Info) -&gt; dict:\n    \"\"\"Fields for each column.\"\"\"\n    names = selections(*info.selected_fields)\n    table = self.table.select(*names).cache()\n    return {name: Column.cast(table[name]) for name in table.columns}\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.distinct","title":"<code>distinct(info, on=None, keep='first', counts='', order='')</code>","text":"<p>Remove duplicate rows from table.</p> <p>Differs from <code>group</code> by keeping all columns, and defaulting to all keys.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    on=\"column names to deduplicate on; defaults to all\",\n    keep=\"which duplicates to keep\",\n    counts=f\"[value counts]({links.ref}/expression-tables#ibis.expr.types.relations.Table.value_counts); incompatible with `keep: null`\",\n    order=\"optionally include and order by first row number; incompatible with `on: null`\",\n)\ndef distinct(\n    self,\n    info: Info,\n    on: list[str] | None = None,\n    keep: str | None = 'first',\n    counts: str = '',\n    order: str = '',\n) -&gt; Self:\n    \"\"\"[Remove duplicate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.distinct) rows from table.\n\n    Differs from `group` by keeping all columns, and defaulting to all keys.\n    \"\"\"\n    table = self.table\n    if order:\n        table = table.mutate({order: ibis.row_number()})\n    if not counts or keep is None:\n        table = table.distinct(on=on, keep=keep)\n    elif on is None:\n        table = table.value_counts(name=counts)\n    else:\n        keys, func = set(on), operator.methodcaller(keep)\n        aggs = {name: func(table[name]) for name in table.columns if name not in keys}\n        aggs[counts] = ibis._.count()\n        table = table.aggregate(aggs, by=on)\n    return self.resolve(info, table.order_by(order) if order else table)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.drop_null","title":"<code>drop_null(info, subset=None, how='any')</code>","text":"<p>Drop rows with null values.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(subset=\"columns names; defaults to all\", how=\"remove if `any` or `all` are null\")\ndef drop_null(self, info: Info, subset: list[str] | None = None, how: str = 'any') -&gt; Self:\n    \"\"\"[Drop](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.drop_null) rows with null values.\"\"\"\n    return self.resolve(info, self.table.drop_null(subset, how=how))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.fill_null","title":"<code>fill_null(info, name=None, value=UNSET, scalar={})</code>","text":"<p>Fill null values.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(name=\"column name(s); defaults to all\", value=\"JSON scalar\", scalar=\"typed scalar\")\ndef fill_null(\n    self,\n    info: Info,\n    name: list[str] | None = None,\n    value: JSON | None = UNSET,\n    scalar: Scalars = {},  # type: ignore\n) -&gt; Self:\n    \"\"\"[Fill null](https://ibis-project.org/reference/expression-tables.html#ibis.expr.types.relations.Table.fill_null) values.\"\"\"\n    (value,) = itertools.chain(scalar, [] if value is UNSET else [value])  # type: ignore\n    replacements = dict.fromkeys(ibis_schema(self.source) if name is None else name, value)\n    return self.resolve(info, self.table.fill_null(replacements))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.filter","title":"<code>filter(info, where=None, **queries)</code>","text":"<p>Filter rows by predicates.</p> <p>Schema derived fields provide syntax for simple queries; <code>where</code> supports complex queries.</p> Source code in <code>graphique/interface.py</code> <pre><code>def filter(self, info: Info, where: Expression | None = None, **queries: Filter) -&gt; Self:\n    \"\"\"[Filter](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.filter) rows by predicates.\n\n    Schema derived fields provide syntax for simple queries; `where` supports complex queries.\n    \"\"\"\n    exprs: list = [] if where is None else list(where)  # type: ignore\n    source = Parquet.filter(self.source, Filter.to_arrow(**queries))\n    if source is None:\n        exprs += Filter.to_exprs(**queries)\n        source = self.table\n    elif exprs:\n        source = Parquet.to_table(source)\n    return self.resolve(info, source.filter(*exprs) if exprs else source)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.group","title":"<code>group(info, by=[], counts='', order='', aggregate={})</code>","text":"<p>Group table by columns.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    by=\"column names; empty will aggregate into a single row table\",\n    counts=\"optionally include counts in an aliased column\",\n    order=\"optionally include and order by first row number\",\n    aggregate=\"aggregation functions applied to other columns\",\n)\ndef group(\n    self,\n    info: Info,\n    by: list[str] = [],\n    counts: str = '',\n    order: str = '',\n    aggregate: Aggregates = {},  # type: ignore\n) -&gt; Self:\n    \"\"\"[Group](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.group_by) table by columns.\"\"\"\n    aggs = dict(aggregate)  # type: ignore\n    if not aggs and not order and by == Parquet.keys(self.source, *by):\n        return self.resolve(info, Parquet.group(self.source, *by, counts=counts))\n    table = self.table\n    if counts:\n        aggs[counts] = ibis._.count()\n    if order:\n        table = table.mutate({order: ibis.row_number()})\n        aggs[order] = table[order].first()\n    table = table.aggregate(aggs, by=by)\n    return self.resolve(info, table.order_by(order) if order else table)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.join","title":"<code>join(info, right, keys, rkeys=[], how='inner', lname='', rname='{name}_right')</code>","text":"<p>Join two tables.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    right=\"name of right table; must be on root Query type\",\n    keys=\"column names used as keys on the left side\",\n    rkeys=\"column names used as keys on the right side; defaults to left side\",\n    how=\"the kind of join: 'inner', 'left', 'right', ...\",\n    lname=\"format string to use to rename overlapping columns in the left table\",\n    rname=\"format string to use to rename overlapping columns in the right table\",\n)\ndef join(\n    self,\n    info: Info,\n    right: str,\n    keys: list[str],\n    rkeys: list[str] = [],\n    how: str = 'inner',\n    lname: str = '',\n    rname: str = '{name}_right',\n) -&gt; Self:\n    \"\"\"[Join](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.join) two tables.\"\"\"\n    left = self.table\n    right = getattr(info.root_value, right).table\n    if rkeys:\n        keys = [getattr(left, key) == getattr(right, rkey) for key, rkey in zip(keys, rkeys)]\n    return self.resolve(\n        info, left.join(right, predicates=keys, how=how, lname=lname, rname=rname)\n    )\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.optional","title":"<code>optional(info)</code>","text":"<p>Nullable field to stop error propagation, enabling partial query results.</p> <p>Will be replaced by client controlled nullability.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field\ndef optional(self, info: Info) -&gt; Self | None:\n    \"\"\"Nullable field to stop error propagation, enabling partial query results.\n\n    Will be replaced by client controlled nullability.\n    \"\"\"\n    return self.resolve(info, self.source)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.order","title":"<code>order(info, by, limit=None, dense=False)</code>","text":"<p>Sort table by columns.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    by=\"column names; prefix with `-` for descending order\",\n    limit=\"maximum number of rows to return; optimized for partitioned dataset keys\",\n    dense=\"use dense rank with `limit`\",\n)\ndef order(\n    self, info: Info, by: list[str], limit: BigInt | None = None, dense: bool = False\n) -&gt; Self:\n    \"\"\"[Sort](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.order_by) table by columns.\"\"\"\n    keys = Parquet.keys(self.source, *by)\n    if keys and limit is not None:\n        table = Parquet.rank(self.source, limit, *keys, dense=dense)\n        if keys == by:\n            return self.resolve(info, table if dense else table[:limit])\n    else:\n        table = self.table\n    if dense and limit is not None:\n        groups = table.aggregate(_=ibis._.count(), by=[name.lstrip('-') for name in by])\n        limit = groups.order_by(*map(order_key, by))[:limit]['_'].sum().to_pyarrow().as_py()\n    return self.resolve(info, table.order_by(*map(order_key, by))[:limit])\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.project","title":"<code>project(info, columns)</code>","text":"<p>Mutate columns by expressions.</p> <p>Renamed to not be confused with a mutation.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field\ndef project(self, info: Info, columns: list[Projection]) -&gt; Self:\n    \"\"\"[Mutate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.mutate) columns by expressions.\n\n    Renamed to not be confused with a mutation.\n    \"\"\"\n    projection = dict(map(Projection.to_ibis, columns))\n    return self.resolve(info, self.table.mutate(projection))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.resolve","title":"<code>resolve(info, source)</code>","text":"<p>Cache the table if it will be reused.</p> Source code in <code>graphique/interface.py</code> <pre><code>def resolve(self, info: Info, source: ibis.Table) -&gt; Self:\n    \"\"\"Cache the table if it will be reused.\"\"\"\n    counts = selections(*info.selected_fields)\n    counts['type'] = counts['schema'] = 0\n    if counts.total() &gt; 1 and isinstance(source, ibis.Table):\n        if names := self.select(info, source):\n            source = source.select(*names).cache()\n    return type(self)(source)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.resolve_reference","title":"<code>resolve_reference(info, **keys)</code>  <code>classmethod</code>","text":"<p>Return table filtered by federated keys.</p> Source code in <code>graphique/interface.py</code> <pre><code>@classmethod\n@no_type_check\ndef resolve_reference(cls, info: Info, **keys) -&gt; Self:\n    \"\"\"Return table filtered by federated keys.\"\"\"\n    self = getattr(info.root_value, cls.field)\n    queries = {name: Filter(eq=[keys[name]]) for name in keys}\n    return self.filter(info, **queries)\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.row","title":"<code>row(info, index=0)</code>","text":"<p>Scalar values at index.</p> Source code in <code>graphique/interface.py</code> <pre><code>def row(self, info: Info, index: int = 0) -&gt; dict:\n    \"\"\"Scalar values at index.\"\"\"\n    names = selections(*info.selected_fields)\n    table = self.table.select(*names)[index:][:1].cache()\n    row = {}\n    for name in table.columns:\n        if isinstance(table[name], ibis.expr.types.ArrayColumn):\n            row[name] = Column.cast(table[name].first().unnest())\n        else:\n            (row[name],) = table[name].to_list()\n    return row\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.runs","title":"<code>runs(info, by=[], split=[], counts='', alias='{}_index', aggregate={})</code>","text":"<p>Provisionally group table by adjacent values in columns.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    by=\"column names to compare by equality\",\n    split=\"boolean column expressions to split on true values\",\n    counts=\"optionally include counts in an aliased column\",\n    alias=\"format string to name index columns\",\n    aggregate=\"aggregation functions applied to other columns\",\n)\ndef runs(\n    self,\n    info: Info,\n    by: list[str] = [],\n    split: list[Projection] = [],\n    counts: str = '',\n    alias: str = '{}_index',\n    aggregate: Aggregates = {},  # type: ignore\n) -&gt; Self:\n    \"\"\"Provisionally group table by adjacent values in columns.\"\"\"\n    table = self.table\n    projection = dict(map(Projection.to_ibis, split))\n    for name in by:\n        column = table[name] != table[name].lag()\n        projection[alias.format(name)] = column.fill_null(False)\n    aggs = {name: ibis._[name].first() for name in by}\n    aggs.update(aggregate)  # type: ignore\n    if counts:\n        aggs[counts] = ibis._.count()\n    table = table.mutate(projection)  # window functions can't be nested\n    table = table.mutate({name: table[name].cumsum() for name in projection})\n    return self.resolve(info, table.aggregate(aggs, by=list(projection)).order_by(*projection))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.select","title":"<code>select(info, source)</code>  <code>staticmethod</code>","text":"<p>Return minimal schema needed to continue.</p> Source code in <code>graphique/interface.py</code> <pre><code>@staticmethod\ndef select(info: Info, source: Source) -&gt; list:\n    \"\"\"Return minimal schema needed to continue.\"\"\"\n    refs: set = set()\n    for field in info.selected_fields:\n        for selection in field.selections:\n            refs.update(references(selection))\n    return [name for name in ibis_schema(source) if name in refs]\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.slice","title":"<code>slice(info, offset=0, limit=None)</code>","text":"<p>Limit row selection.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    offset=\"number of rows to skip; negative value skips from the end\",\n    limit=\"maximum number of rows to return\",\n)\ndef slice(self, info: Info, offset: BigInt = 0, limit: BigInt | None = None) -&gt; Self:\n    \"\"\"[Limit](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.limit) row selection.\"\"\"\n    return self.resolve(info, self.table[offset:][:limit])\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.take","title":"<code>take(info, indices)</code>","text":"<p>Take rows by index.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field\ndef take(self, info: Info, indices: list[BigInt]) -&gt; Self:\n    \"\"\"[Take](https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Dataset.html#pyarrow.dataset.Dataset.take) rows by index.\"\"\"\n    names = self.select(info, self.source)\n    if isinstance(self.source, ds.Dataset):\n        table = self.source.take(indices, columns=names)\n    else:\n        batches = self.source.select(*names).to_pyarrow_batches()\n        table = ds.Scanner.from_batches(batches).take(indices)\n    return type(self)(ibis.memtable(table))\n</code></pre>"},{"location":"reference/#graphique.interface.Dataset.unnest","title":"<code>unnest(info, name, offset='', keep_empty=False, row_number='')</code>","text":"<p>Unnest an array column from a table.</p> Source code in <code>graphique/interface.py</code> <pre><code>@doc_field(\n    name=\"column name\",\n    offset=\"optionally include index column\",\n    keep_empty=\"keep empty array values as null\",\n    row_number=\"optionally include first row number in an aliased column\",\n)\ndef unnest(\n    self,\n    info: Info,\n    name: str,\n    offset: str = '',\n    keep_empty: bool = False,\n    row_number: str = '',\n) -&gt; Self:\n    \"\"\"[Unnest](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.unnest) an array column from a table.\"\"\"\n    table = self.table\n    if row_number:\n        table = table.mutate({row_number: ibis.row_number()})\n    return self.resolve(info, table.unnest(name, offset=offset or None, keep_empty=keep_empty))\n</code></pre>"},{"location":"reference/#graphique.middleware.GraphQL","title":"<code>graphique.middleware.GraphQL</code>","text":"<p>               Bases: <code>GraphQL</code></p> <p>ASGI GraphQL app with root value(s).</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Source</code> <p>root dataset to attach as the Query type</p> required <code>metrics</code> <code>bool</code> <p>enable timing extension</p> <code>False</code> <code>**kwargs</code> <p>additional <code>asgi.GraphQL</code> options</p> <code>{}</code> Source code in <code>graphique/middleware.py</code> <pre><code>class GraphQL(strawberry.asgi.GraphQL):\n    \"\"\"ASGI GraphQL app with root value(s).\n\n    Args:\n        root: root dataset to attach as the Query type\n        metrics: enable timing extension\n        **kwargs: additional `asgi.GraphQL` options\n    \"\"\"\n\n    options = dict(types=Column.registry.values(), scalar_overrides=scalar_map)\n\n    def __init__(self, root: Source, metrics: bool = False, **kwargs):\n        options: dict = dict(self.options, extensions=[MetricsExtension] if metrics else [])\n        if type(root).__name__ == 'Query':\n            self.root_value = root\n            options['enable_federation_2'] = True\n            schema = strawberry.federation.Schema(type(self.root_value), **options)\n        else:\n            self.root_value = implemented(root)\n            schema = strawberry.Schema(type(self.root_value), **options)\n        super().__init__(schema, **kwargs)\n\n    async def get_root_value(self, request):\n        return self.root_value\n\n    @classmethod\n    def federated(cls, roots: Mapping[str, Source], keys: Mapping[str, Iterable] = {}, **kwargs):\n        \"\"\"Construct GraphQL app with multiple federated datasets.\n\n        Args:\n            roots: mapping of field names to root datasets\n            keys: mapping of optional federation keys for each root\n            **kwargs: additional `asgi.GraphQL` options\n        \"\"\"\n        root_values = {name: implemented(roots[name], name, keys.get(name, ())) for name in roots}\n        annotations = {name: type(root_values[name]) for name in root_values}\n        Query = type('Query', (), {'__annotations__': annotations})\n        return cls(strawberry.type(Query)(**root_values), **kwargs)\n</code></pre>"},{"location":"reference/#graphique.middleware.GraphQL.federated","title":"<code>federated(roots, keys={}, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct GraphQL app with multiple federated datasets.</p> <p>Parameters:</p> Name Type Description Default <code>roots</code> <code>Mapping[str, Source]</code> <p>mapping of field names to root datasets</p> required <code>keys</code> <code>Mapping[str, Iterable]</code> <p>mapping of optional federation keys for each root</p> <code>{}</code> <code>**kwargs</code> <p>additional <code>asgi.GraphQL</code> options</p> <code>{}</code> Source code in <code>graphique/middleware.py</code> <pre><code>@classmethod\ndef federated(cls, roots: Mapping[str, Source], keys: Mapping[str, Iterable] = {}, **kwargs):\n    \"\"\"Construct GraphQL app with multiple federated datasets.\n\n    Args:\n        roots: mapping of field names to root datasets\n        keys: mapping of optional federation keys for each root\n        **kwargs: additional `asgi.GraphQL` options\n    \"\"\"\n    root_values = {name: implemented(roots[name], name, keys.get(name, ())) for name in roots}\n    annotations = {name: type(root_values[name]) for name in root_values}\n    Query = type('Query', (), {'__annotations__': annotations})\n    return cls(strawberry.type(Query)(**root_values), **kwargs)\n</code></pre>"},{"location":"schema/","title":"Example Schema","text":"<p>Generated from a test fixture of zipcodes.</p>"},{"location":"schema/#query-table","title":"Query (Table)","text":"<p>a dataset with a derived schema</p> Field Argument Type Description type String!   [ibis table](https://ibis-project.org/reference/expression-table) or [arrow dataset](https://arrow.apache.org/docs/python/api/dataset.html)   schema Schema!   [table schema](https://ibis-project.org/reference/schemas#ibis.expr.schema.Schema)   cast Table!   [Cast](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.cast) the columns of a table.   schema [Field!]!   field names and types   try Boolean!   return null if cast fails   optional Table   Nullable field to stop error propagation, enabling partial query results.  Will be replaced by client controlled nullability.   count BigInt!   [Count](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.count) the number of rows.   any Boolean!   Whether there are at least `limit` rows.  May be significantly faster than `count` for out-of-core data.   limit BigInt! column Column   Column of any type by name.  If the column is in the schema, `columns` can be used instead.   name [String!]!   column name(s); multiple names access nested struct fields   cast String!   cast expression to indicated [data type](https://ibis-project.org/reference/datatypes)   try Boolean!   return null if cast fails   slice Table!   [Limit](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.limit) row selection.   offset BigInt!   number of rows to skip; negative value skips from the end   limit BigInt   maximum number of rows to return   distinct Table!   [Remove duplicate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.distinct) rows from table.  Differs from `group` by keeping all columns, and defaulting to all keys.   on [String!]   column names to deduplicate on; defaults to all   keep String   which duplicates to keep   counts String!   [value counts](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.value_counts); incompatible with `keep: null`   order String!   optionally include and order by first row number; incompatible with `on: null`   group Table!   [Group](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.group_by) table by columns.   by [String!]!   column names; empty will aggregate into a single row table   counts String!   optionally include counts in an aliased column   order String!   optionally include and order by first row number   aggregate Aggregates!   aggregation functions applied to other columns   order Table!   [Sort](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.order_by) table by columns.   by [String!]!   column names; prefix with `-` for descending order   limit BigInt   maximum number of rows to return; optimized for partitioned dataset keys   dense Boolean!   use dense rank with `limit`   unnest Table!   [Unnest](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.unnest) an array column from a table.   name String!   column name   offset String!   optionally include index column   keepEmpty Boolean!   keep empty array values as null   rowNumber String!   optionally include first row number in an aliased column   join Table!   [Join](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.join) two tables.   right String!   name of right table; must be on root Query type   keys [String!]!   column names used as keys on the left side   rkeys [String!]!   column names used as keys on the right side; defaults to left side   how String!   the kind of join: 'inner', 'left', 'right', ...   lname String!   format string to use to rename overlapping columns in the left table   rname String!   format string to use to rename overlapping columns in the right table   take Table!   [Take](https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Dataset.html#pyarrow.dataset.Dataset.take) rows by index.   indices [BigInt!]! dropNull Table!   [Drop](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.drop_null) rows with null values.   subset [String!]   columns names; defaults to all   how String!   remove if `any` or `all` are null   fillNull Table!   [Fill null](https://ibis-project.org/reference/expression-tables.html#ibis.expr.types.relations.Table.fill_null) values.   name [String!]   column name(s); defaults to all   value JSON   JSON scalar   scalar Scalars!   typed scalar   project Table!   [Mutate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.mutate) columns by expressions.  Renamed to not be confused with a mutation.   columns [Projection!]! runs Table!   Provisionally group table by adjacent values in columns.   by [String!]!   column names to compare by equality   split [Projection!]!   boolean column expressions to split on true values   counts String!   optionally include counts in an aliased column   alias String!   format string to name index columns   aggregate Aggregates!   aggregation functions applied to other columns   columns Columns!   fields for each column   row Row   Return scalar values at index.   index BigInt! filter Table!   [Filter](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.filter) rows by predicates.  Schema derived fields provide syntax for simple queries; `where` supports complex queries.   latitude FloatFilter! longitude FloatFilter! state StrFilter! city StrFilter! county StrFilter! zipcode IntFilter! where Expression"},{"location":"schema/#objects","title":"Objects","text":""},{"location":"schema/#arraycolumn","title":"ArrayColumn","text":"<p>array column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean!"},{"location":"schema/#base64column","title":"Base64Column","text":"<p>generic column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Base64]!   list of values   distinct Base64Set!   distinct values and counts   first Base64   Return the first value of a column.   last Base64   Return the last value of a column.   dropNull [Base64!]!   non-null values   fillNull [Base64!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Base64! mode Base64   Return the mode of a column.   min Base64   Return the minimum of a column.   max Base64   Return the maximum of a column.   quantile [Base64!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#base64set","title":"Base64Set","text":"<p>distinct values and counts</p> Field Argument Type Description values [Base64]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#bigintcolumn","title":"BigIntColumn","text":"<p>integer column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [BigInt]!   list of values   distinct BigIntSet!   distinct values and counts   first BigInt   Return the first value of a column.   last BigInt   Return the last value of a column.   dropNull [BigInt!]!   non-null values   fillNull [BigInt!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value BigInt! mode BigInt   Return the mode of a column.   min BigInt   Return the minimum of a column.   max BigInt   Return the maximum of a column.   quantile [Float!]   Return value at the given quantile.   q [Float!]! approx Boolean! sum BigInt   Return the sum of a numeric column.   mean Float   Return the mean of a numeric column.   std Float   Return the standard deviation of a numeric column.   how String! var Float   Return the variance of a numeric column.   how String! takeFrom Dataset   Select indices from a table on the root Query type.   field String!"},{"location":"schema/#bigintset","title":"BigIntSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [BigInt]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#boolset","title":"BoolSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Boolean]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#booleancolumn","title":"BooleanColumn","text":"<p>boolean column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Boolean]!   list of values   distinct BoolSet!   distinct values and counts   first Boolean   Return the first value of a column.   last Boolean   Return the last value of a column.   dropNull [Boolean!]!   non-null values   fillNull [Boolean!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Boolean! mode Boolean   Return the mode of a column.   min Boolean   Return the minimum of a column.   max Boolean   Return the maximum of a column.   quantile [Float!]   Return value at the given quantile.   q [Float!]! approx Boolean! sum Boolean   Return the sum of a numeric column.   mean Float   Return the mean of a numeric column.   std Float   Return the standard deviation of a numeric column.   how String! var Float   Return the variance of a numeric column.   how String! any Boolean   Return whether at least one element is `True`.   all Boolean   Return whether all elements are `True`."},{"location":"schema/#columns","title":"Columns","text":"<p>fields for each column</p> Field Argument Type Description latitude FloatColumn longitude FloatColumn state StringColumn city StringColumn county StringColumn zipcode IntColumn"},{"location":"schema/#datecolumn","title":"DateColumn","text":"<p>temporal column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Date]!   list of values   distinct DateSet!   distinct values and counts   first Date   Return the first value of a column.   last Date   Return the last value of a column.   dropNull [Date!]!   non-null values   fillNull [Date!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Date! mode Date   Return the mode of a column.   min Date   Return the minimum of a column.   max Date   Return the maximum of a column.   quantile [Date!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#dateset","title":"DateSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Date]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#datetimecolumn","title":"DatetimeColumn","text":"<p>temporal column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [DateTime]!   list of values   distinct DatetimeSet!   distinct values and counts   first DateTime   Return the first value of a column.   last DateTime   Return the last value of a column.   dropNull [DateTime!]!   non-null values   fillNull [DateTime!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value DateTime! mode DateTime   Return the mode of a column.   min DateTime   Return the minimum of a column.   max DateTime   Return the maximum of a column.   quantile [DateTime!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#datetimeset","title":"DatetimeSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [DateTime]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#decimalcolumn","title":"DecimalColumn","text":"<p>numeric column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Decimal]!   list of values   distinct DecimalSet!   distinct values and counts   first Decimal   Return the first value of a column.   last Decimal   Return the last value of a column.   dropNull [Decimal!]!   non-null values   fillNull [Decimal!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Decimal! mode Decimal   Return the mode of a column.   min Decimal   Return the minimum of a column.   max Decimal   Return the maximum of a column.   quantile [Float!]   Return value at the given quantile.   q [Float!]! approx Boolean! sum Decimal   Return the sum of a numeric column.   mean Float   Return the mean of a numeric column.   std Float   Return the standard deviation of a numeric column.   how String! var Float   Return the variance of a numeric column.   how String!"},{"location":"schema/#decimalset","title":"DecimalSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Decimal]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#durationcolumn","title":"DurationColumn","text":"<p>provisional interval column</p> <p>Interval support varies by backend; durations may still be useful for computation and as scalar inputs.</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Duration]!   list of values   distinct DurationSet!   distinct values and counts   first Duration   Return the first value of a column.   last Duration   Return the last value of a column.   dropNull [Duration!]!   non-null values   fillNull [Duration!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Duration! mode Duration   Return the mode of a column.   min Duration   Return the minimum of a column.   max Duration   Return the maximum of a column.   quantile [Duration!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#durationset","title":"DurationSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Duration]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#floatcolumn","title":"FloatColumn","text":"<p>numeric column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Float]!   list of values   distinct FloatSet!   distinct values and counts   first Float   Return the first value of a column.   last Float   Return the last value of a column.   dropNull [Float!]!   non-null values   fillNull [Float!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Float! mode Float   Return the mode of a column.   min Float   Return the minimum of a column.   max Float   Return the maximum of a column.   quantile [Float!]   Return value at the given quantile.   q [Float!]! approx Boolean! sum Float   Return the sum of a numeric column.   mean Float   Return the mean of a numeric column.   std Float   Return the standard deviation of a numeric column.   how String! var Float   Return the variance of a numeric column.   how String!"},{"location":"schema/#floatset","title":"FloatSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Float]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#intcolumn","title":"IntColumn","text":"<p>integer column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Int]!   list of values   distinct IntSet!   distinct values and counts   first Int   Return the first value of a column.   last Int   Return the last value of a column.   dropNull [Int!]!   non-null values   fillNull [Int!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Int! mode Int   Return the mode of a column.   min Int   Return the minimum of a column.   max Int   Return the maximum of a column.   quantile [Float!]   Return value at the given quantile.   q [Float!]! approx Boolean! sum Int   Return the sum of a numeric column.   mean Float   Return the mean of a numeric column.   std Float   Return the standard deviation of a numeric column.   how String! var Float   Return the variance of a numeric column.   how String! takeFrom Dataset   Select indices from a table on the root Query type.   field String!"},{"location":"schema/#intset","title":"IntSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Int]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#jsoncolumn","title":"JSONColumn","text":"<p>struct column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [JSON]!   list of values   distinct JSONSet!   distinct values and counts   first JSON   Return the first value of a column.   last JSON   Return the last value of a column.   dropNull [JSON!]!   non-null values   fillNull [JSON!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value JSON! mode JSON   Return the mode of a column.   min JSON   Return the minimum of a column.   max JSON   Return the maximum of a column.   quantile [JSON!]   Return value at the given quantile.   q [Float!]! names [String!]!   field names"},{"location":"schema/#jsonset","title":"JSONSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [JSON]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#row","title":"Row","text":"<p>scalar fields</p> Field Argument Type Description latitude Float longitude Float state String city String county String zipcode Int"},{"location":"schema/#schema","title":"Schema","text":"<p>table schema</p> Field Argument Type Description names [String!]!   field names   types [String!]!   [data type](https://ibis-project.org/reference/datatypes), corresponding to `names`   partitioning [String!]!   partition keys"},{"location":"schema/#strset","title":"StrSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [String]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#stringcolumn","title":"StringColumn","text":"<p>string column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [String]!   list of values   distinct StrSet!   distinct values and counts   first String   Return the first value of a column.   last String   Return the last value of a column.   dropNull [String!]!   non-null values   fillNull [String!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value String! mode String   Return the mode of a column.   min String   Return the minimum of a column.   max String   Return the maximum of a column.   quantile [String!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#timecolumn","title":"TimeColumn","text":"<p>temporal column</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! values [Time]!   list of values   distinct TimeSet!   distinct values and counts   first Time   Return the first value of a column.   last Time   Return the last value of a column.   dropNull [Time!]!   non-null values   fillNull [Time!]!   Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.   value Time! mode Time   Return the mode of a column.   min Time   Return the minimum of a column.   max Time   Return the maximum of a column.   quantile [Time!]   Return value at the given quantile.   q [Float!]!"},{"location":"schema/#timeset","title":"TimeSet","text":"<p>distinct values and counts</p> Field Argument Type Description values [Time]!   distinct values   counts [BigInt!]!   corresponding counts"},{"location":"schema/#inputs","title":"Inputs","text":""},{"location":"schema/#aggregate","title":"Aggregate","text":"<p>name and optional alias for aggregation</p> Field Type Description name String!   column name   alias String!   output column name   where Expression"},{"location":"schema/#aggregates","title":"Aggregates","text":"<p>aggregation expressions</p> Field Type Description all [Aggregate!]!   Return whether all elements are `True`.   any [Aggregate!]!   Return whether at least one element is `True`.   collect [CollectAggregate!]!   Aggregate this expression's elements into an array.   count [Aggregate!]!   Compute the number of rows in an expression.   first [OrderAggregate!]!   Return the first value of a column.   last [OrderAggregate!]!   Return the last value of a column.   max [Aggregate!]!   Return the maximum of a column.   mean [Aggregate!]!   Return the mean of a numeric column.   min [Aggregate!]!   Return the minimum of a column.   nunique [UniqueAggregate!]!   Compute the number of distinct rows in an expression.   quantile [QuantileAggregate!]!   Return value at the given quantile.   std [VarAggregate!]!   Return the standard deviation of a numeric column.   sum [Aggregate!]!   Return the sum of a numeric column.   var [VarAggregate!]!   Return the variance of a numeric column."},{"location":"schema/#arrays","title":"Arrays","text":"<p>array expressions</p> Field Type Description alls Expression   Return whether all elements (ignoring nulls) in the array are true.   anys Expression   Return whether any element in the array is true.   length Expression   Compute the length of an array.   maxs Expression   Return the maximum value in the array.   means Expression   Return the mean of the values in the array.   modes Expression   Return the mode of the values in the array.   mins Expression   Return the minimum value in the array.   sort Expression   Sort the elements in an array.   sums Expression   Return the sum of the values in the array.   unique Expression   Return the unique values in an array.   index [Expression!]!   Return the position of `other` in an array.   slice Expression   array slice   value Expression   value at offset   offset Int! limit Int"},{"location":"schema/#collectaggregate","title":"CollectAggregate","text":"Field Type Description name String!   column name   alias String!   output column name   where Expression orderBy [String!]! includeNull Boolean! distinct Boolean!"},{"location":"schema/#expression","title":"Expression","text":"<p>expression API</p> Field Type Description name [String!]!   column name(s)   value JSON   JSON scalar   scalar Scalars   typed scalar   rowNumber Void   Return an analytic function expression for the current row number.   eq [Expression!]!   ==   ne [Expression!]!   !=   lt [Expression!]! &lt; le [Expression!]! &lt;=   gt [Expression!]!   \\&gt;   ge [Expression!]!   \\&gt;=   isin [Expression!]!   Check whether this expression is in `values`.   notin [Expression!]!   Check whether this expression is not in `values`.   inv Expression   ~   and [Expression!]!   &amp;   or [Expression!]!   |   xor [Expression!]!   ^   add [Expression!]!   +   sub [Expression!]!   -   mul [Expression!]!   *   div [Expression!]!   /   coalesce [Expression!]!   Return the first non-null value from `args`.   cumeDist Expression   Return the cumulative distribution over a window.   cummax Expression   Return the cumulative max over a window.   cummin Expression   Return the cumulative min over a window.   denseRank Expression   Position of first element within each group of equal values.   ifelse [Expression!]!   Construct a ternary conditional expression.   percentRank Expression   Return the relative rank of the values in the column.   rank Expression   Compute position of first element within each equal-value group in sorted order.   array Arrays   array value functions   numeric Numeric   numeric functions   string Strings   string functions   temporal Temporal   temporal functions   window Window   window functions"},{"location":"schema/#field","title":"Field","text":"<p>a schema field</p> Field Type Description name String! type String!"},{"location":"schema/#floatfilter","title":"FloatFilter","text":"<p>predicates for scalars</p> Field Type Description eq [Float!]   == or `isin`   ne [Float!]   != or `notin`   lt Float &lt; le Float &lt;=   gt Float   \\&gt;   ge Float   \\&gt;="},{"location":"schema/#intfilter","title":"IntFilter","text":"<p>predicates for scalars</p> Field Type Description eq [Int!]   == or `isin`   ne [Int!]   != or `notin`   lt Int &lt; le Int &lt;=   gt Int   \\&gt;   ge Int   \\&gt;="},{"location":"schema/#numeric","title":"Numeric","text":"<p>numeric expressions</p> Field Type Description abs Expression   Return the absolute value of `self`.   acos Expression   Compute the arc cosine of `self`.   asin Expression   Compute the arc sine of `self`.   atan Expression   Compute the arc tangent of `self`.   atan2 [Expression!]!   Compute the two-argument version of arc tangent.   ceil Expression   Return the ceiling of `self`.   cos Expression   Compute the cosine of `self`.   exp Expression   Compute $e^\\texttt{self}$.   floor Expression   Return the floor of an expression.   isinf Expression   Return whether the value is +/-inf. Does NOT detect `NULL` and `inf` values.   isnan Expression   Return whether the value is NaN. Does NOT detect `NULL` and `inf` values.   log [Expression!]!   Compute $\\log_{\\texttt{base}}\\left(\\texttt{self}\\right)$.   negate Expression   Negate a numeric expression.   round [Expression!]!   Round values to an indicated number of decimal places.   sign Expression   Return the sign of the input.   sin Expression   Compute the sine of `self`.   sqrt Expression   Compute the square root of `self`.   tan Expression   Compute the tangent of `self`.   bucket Expression   Compute a discrete binning of a numeric array.   cummean Expression   Return the cumulative mean of the input.   cumsum Expression   Return the cumulative sum of the input.   buckets [JSON!]! closed String! closeExtreme Boolean! includeUnder Boolean! includeOver Boolean!"},{"location":"schema/#orderaggregate","title":"OrderAggregate","text":"Field Type Description name String!   column name   alias String!   output column name   where Expression orderBy [String!]! includeNull Boolean!"},{"location":"schema/#projection","title":"Projection","text":"<p>an <code>Expression</code> with an optional alias</p> Field Type Description name [String!]!   column name(s)   value JSON   JSON scalar   scalar Scalars   typed scalar   rowNumber Void   Return an analytic function expression for the current row number.   eq [Expression!]!   ==   ne [Expression!]!   !=   lt [Expression!]! &lt; le [Expression!]! &lt;=   gt [Expression!]!   \\&gt;   ge [Expression!]!   \\&gt;=   isin [Expression!]!   Check whether this expression is in `values`.   notin [Expression!]!   Check whether this expression is not in `values`.   inv Expression   ~   and [Expression!]!   &amp;   or [Expression!]!   |   xor [Expression!]!   ^   add [Expression!]!   +   sub [Expression!]!   -   mul [Expression!]!   *   div [Expression!]!   /   coalesce [Expression!]!   Return the first non-null value from `args`.   cumeDist Expression   Return the cumulative distribution over a window.   cummax Expression   Return the cumulative max over a window.   cummin Expression   Return the cumulative min over a window.   denseRank Expression   Position of first element within each group of equal values.   ifelse [Expression!]!   Construct a ternary conditional expression.   percentRank Expression   Return the relative rank of the values in the column.   rank Expression   Compute position of first element within each equal-value group in sorted order.   array Arrays   array value functions   numeric Numeric   numeric functions   string Strings   string functions   temporal Temporal   temporal functions   window Window   window functions   alias String!   name of projected column"},{"location":"schema/#quantileaggregate","title":"QuantileAggregate","text":"Field Type Description name String!   column name   alias String!   output column name   where Expression approx Boolean! q Float!"},{"location":"schema/#scalars","title":"Scalars","text":"<p>typed scalars</p> Field Type Description base64 Base64   binary scalar   date Date   date scalar   datetime DateTime   datetime scalar   decimal Decimal   decimal scalar   duration Duration   duration scalar   time Time   time scalar"},{"location":"schema/#strfilter","title":"StrFilter","text":"<p>predicates for scalars</p> Field Type Description eq [String!]   == or `isin`   ne [String!]   != or `notin`   lt String &lt; le String &lt;=   gt String   \\&gt;   ge String   \\&gt;="},{"location":"schema/#strings","title":"Strings","text":"<p>string expressions</p> Field Type Description capitalize Expression   Uppercase the first letter, lowercase the rest.   contains [Expression!]!   Return whether the expression contains `substr`.   endswith [Expression!]!   Determine if `self` ends with `end`.   find [Expression!]!   Return the position of the first occurrence of substring.   length Expression   Compute the length of a string.   lower Expression   Convert string to all lowercase.   lpad [Expression!]!   Pad `arg` by truncating on the right or padding on the left.   lstrip [Expression!]!   Remove whitespace from the left side of string.   reExtract [Expression!]!   Return the specified match at `index` from a regex `pattern`.   reSearch [Expression!]!   Return whether `self` contains the regex `pattern`.   reSplit [Expression!]!   Split a string by a regular expression `pattern`.   replace [Expression!]!   Replace each exact match of `pattern` with `replacement`.   reverse Expression   Reverse the characters of a string.   rpad [Expression!]!   Pad `self` by truncating or padding on the right.   rstrip [Expression!]!   Remove whitespace from the right side of string.   split [Expression!]!   Split as string on `delimiter`.   startswith [Expression!]!   Determine whether `self` starts with `start`.   strip [Expression!]!   Remove whitespace from left and right sides of a string.   upper Expression   Convert string to all uppercase."},{"location":"schema/#temporal","title":"Temporal","text":"<p>temporal expressions</p> Field Type Description date Expression   Return the date component of the expression.   day Expression   Extract the day component.   dayOfYear Expression   Extract the day of the year component.   delta [Expression!]!   Compute the number of `part`s between two timestamps.   epochSeconds Expression   Extract UNIX epoch in seconds.   hour Expression   Extract the hour component.   microsecond Expression   Extract the microsecond component.   millisecond Expression   Extract the millisecond component.   minute Expression   Extract the minute component.   month Expression   Extract the month component.   quarter Expression   Extract the quarter component.   second Expression   Extract the second component.   strftime Expression   Format a timestamp according to `format_str`.   time Expression   Return the time component of the expression.   truncate Expression   Truncate timestamp expression to units of `unit`.   weekOfYear Expression   Extract the week of the year component.   year Expression   Extract the year component.   formatStr String! unit String!"},{"location":"schema/#uniqueaggregate","title":"UniqueAggregate","text":"Field Type Description name String!   column name   alias String!   output column name   where Expression approx Boolean!"},{"location":"schema/#varaggregate","title":"VarAggregate","text":"Field Type Description name String!   column name   alias String!   output column name   where Expression how String!"},{"location":"schema/#window","title":"Window","text":"<p>window expressions</p> Field Type Description lag Expression   Return the row located at `offset` rows **before** the current row.   lead Expression   Return the row located at `offset` rows **after** the current row.   eq Expression   pairwise ==   ne Expression   pairwise !=   lt Expression   pairwise &lt; le Expression   pairwise &lt;=   gt Expression   pairwise \\&gt;   ge Expression   pairwise \\&gt;=   sub Expression   pairwise -   offset Int! default JSON   default JSON scalar   scalar Scalars   default typed scalar"},{"location":"schema/#scalars_1","title":"Scalars","text":""},{"location":"schema/#base64","title":"Base64","text":"<p>Represents binary data as Base64-encoded strings, using the standard alphabet.</p>"},{"location":"schema/#bigint","title":"BigInt","text":"<p>64-bit int</p>"},{"location":"schema/#boolean","title":"Boolean","text":"<p>The <code>Boolean</code> scalar type represents <code>true</code> or <code>false</code>.</p>"},{"location":"schema/#date","title":"Date","text":"<p>Date (isoformat)</p>"},{"location":"schema/#datetime","title":"DateTime","text":"<p>Date with time (isoformat)</p>"},{"location":"schema/#decimal","title":"Decimal","text":"<p>Decimal (fixed-point)</p>"},{"location":"schema/#duration","title":"Duration","text":"<p>Duration (isoformat)</p>"},{"location":"schema/#float","title":"Float","text":"<p>The <code>Float</code> scalar type represents signed double-precision fractional values as specified by IEEE 754.</p>"},{"location":"schema/#int","title":"Int","text":"<p>The <code>Int</code> scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.</p>"},{"location":"schema/#json","title":"JSON","text":"<p>The <code>JSON</code> scalar type represents JSON values as specified by ECMA-404.</p>"},{"location":"schema/#string","title":"String","text":"<p>The <code>String</code> scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.</p>"},{"location":"schema/#time","title":"Time","text":"<p>Time (isoformat)</p>"},{"location":"schema/#void","title":"Void","text":"<p>Represents NULL values</p>"},{"location":"schema/#interfaces","title":"Interfaces","text":""},{"location":"schema/#column","title":"Column","text":"<p>ibis column interface</p> Field Argument Type Description type String!   [data type](https://ibis-project.org/reference/datatypes)   count BigInt!   Compute the number of rows in an expression.   nunique BigInt!   Compute the number of distinct rows in an expression.   approx Boolean! <p>Possible Types: ArrayColumn, Base64Column, BigIntColumn, BooleanColumn, DateColumn, DatetimeColumn, DecimalColumn, DurationColumn, FloatColumn, IntColumn, JSONColumn, StringColumn, TimeColumn</p>"},{"location":"schema/#dataset","title":"Dataset","text":"<p>ibis <code>Table</code> or arrow <code>Dataset</code></p> Field Argument Type Description type String!   [ibis table](https://ibis-project.org/reference/expression-table) or [arrow dataset](https://arrow.apache.org/docs/python/api/dataset.html)   schema Schema!   [table schema](https://ibis-project.org/reference/schemas#ibis.expr.schema.Schema)   cast Dataset!   [Cast](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.cast) the columns of a table.   schema [Field!]!   field names and types   try Boolean!   return null if cast fails   optional Dataset   Nullable field to stop error propagation, enabling partial query results.  Will be replaced by client controlled nullability.   count BigInt!   [Count](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.count) the number of rows.   any Boolean!   Whether there are at least `limit` rows.  May be significantly faster than `count` for out-of-core data.   limit BigInt! column Column   Column of any type by name.  If the column is in the schema, `columns` can be used instead.   name [String!]!   column name(s); multiple names access nested struct fields   cast String!   cast expression to indicated [data type](https://ibis-project.org/reference/datatypes)   try Boolean!   return null if cast fails   slice Dataset!   [Limit](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.limit) row selection.   offset BigInt!   number of rows to skip; negative value skips from the end   limit BigInt   maximum number of rows to return   distinct Dataset!   [Remove duplicate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.distinct) rows from table.  Differs from `group` by keeping all columns, and defaulting to all keys.   on [String!]   column names to deduplicate on; defaults to all   keep String   which duplicates to keep   counts String!   [value counts](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.value_counts); incompatible with `keep: null`   order String!   optionally include and order by first row number; incompatible with `on: null`   group Dataset!   [Group](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.group_by) table by columns.   by [String!]!   column names; empty will aggregate into a single row table   counts String!   optionally include counts in an aliased column   order String!   optionally include and order by first row number   aggregate Aggregates!   aggregation functions applied to other columns   order Dataset!   [Sort](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.order_by) table by columns.   by [String!]!   column names; prefix with `-` for descending order   limit BigInt   maximum number of rows to return; optimized for partitioned dataset keys   dense Boolean!   use dense rank with `limit`   unnest Dataset!   [Unnest](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.unnest) an array column from a table.   name String!   column name   offset String!   optionally include index column   keepEmpty Boolean!   keep empty array values as null   rowNumber String!   optionally include first row number in an aliased column   join Dataset!   [Join](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.join) two tables.   right String!   name of right table; must be on root Query type   keys [String!]!   column names used as keys on the left side   rkeys [String!]!   column names used as keys on the right side; defaults to left side   how String!   the kind of join: 'inner', 'left', 'right', ...   lname String!   format string to use to rename overlapping columns in the left table   rname String!   format string to use to rename overlapping columns in the right table   take Dataset!   [Take](https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Dataset.html#pyarrow.dataset.Dataset.take) rows by index.   indices [BigInt!]! dropNull Dataset!   [Drop](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.drop_null) rows with null values.   subset [String!]   columns names; defaults to all   how String!   remove if `any` or `all` are null   fillNull Dataset!   [Fill null](https://ibis-project.org/reference/expression-tables.html#ibis.expr.types.relations.Table.fill_null) values.   name [String!]   column name(s); defaults to all   value JSON   JSON scalar   scalar Scalars!   typed scalar   project Dataset!   [Mutate](https://ibis-project.org/reference/expression-tables#ibis.expr.types.relations.Table.mutate) columns by expressions.  Renamed to not be confused with a mutation.   columns [Projection!]! runs Dataset!   Provisionally group table by adjacent values in columns.   by [String!]!   column names to compare by equality   split [Projection!]!   boolean column expressions to split on true values   counts String!   optionally include counts in an aliased column   alias String!   format string to name index columns   aggregate Aggregates!   aggregation functions applied to other columns   <p>Possible Types: Table</p>"}]}