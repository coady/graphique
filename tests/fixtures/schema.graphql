schema {
  query: IndexedTable
}

"""base64 encoded bytes"""
scalar Binary

"""column of binaries"""
type BinaryColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Binary, notEqual: Binary, isIn: [Binary!]): Long!

  """list of values"""
  values: [Binary]!

  """length of bytes or strings"""
  binaryLength: IntColumn!
}

"""predicates for binaries"""
input BinaryFilter {
  equal: Binary
  notEqual: Binary
  isIn: [Binary!]
  project: Nominal
}

"""column of booleans"""
type BooleanColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Boolean, notEqual: Boolean): Long!

  """list of values"""
  values: [Boolean]!

  """unique values and counts"""
  unique: BooleanSet!
}

"""predicates for booleans"""
input BooleanFilter {
  equal: Boolean
  notEqual: Boolean
  project: Nominal
}

"""unique booleans"""
type BooleanSet {
  counts: [Long!]!

  """number of rows"""
  length: Long!

  """list of values"""
  values: [Boolean]!
}

"""fields for each column"""
type Columns {
  bool: BooleanColumn!

  """Return column with optional projection."""
  uint8(add: String, subtract: String, multiply: String, minimum: String, maximum: String): IntColumn!

  """Return column with optional projection."""
  int8(add: String, subtract: String, multiply: String, minimum: String, maximum: String): IntColumn!

  """Return column with optional projection."""
  uint16(add: String, subtract: String, multiply: String, minimum: String, maximum: String): IntColumn!

  """Return column with optional projection."""
  int16(add: String, subtract: String, multiply: String, minimum: String, maximum: String): IntColumn!

  """Return column with optional projection."""
  uint32(add: String, subtract: String, multiply: String, minimum: String, maximum: String): LongColumn!

  """Return column with optional projection."""
  int32(add: String, subtract: String, multiply: String, minimum: String, maximum: String): IntColumn!

  """Return column with optional projection."""
  uint64(add: String, subtract: String, multiply: String, minimum: String, maximum: String): LongColumn!

  """Return column with optional projection."""
  int64(add: String, subtract: String, multiply: String, minimum: String, maximum: String): LongColumn!

  """Return column with optional projection."""
  float(add: String, subtract: String, multiply: String, minimum: String, maximum: String): FloatColumn!

  """Return column with optional projection."""
  double(add: String, subtract: String, multiply: String, minimum: String, maximum: String): FloatColumn!

  """Return column with optional projection."""
  decimal(minimum: String, maximum: String): DecimalColumn!

  """Return column with optional projection."""
  date32(minimum: String, maximum: String): DateColumn!

  """Return column with optional projection."""
  date64(minimum: String, maximum: String): DateColumn!

  """Return column with optional projection."""
  timestamp(minimum: String, maximum: String): DateTimeColumn!

  """Return column with optional projection."""
  time32(minimum: String, maximum: String): TimeColumn!

  """Return column with optional projection."""
  time64(minimum: String, maximum: String): TimeColumn!
  binary: BinaryColumn!

  """Return column with optional projection."""
  string(minimum: String, maximum: String): StringColumn!

  """Return column with optional projection."""
  snakeId(add: String, subtract: String, multiply: String, minimum: String, maximum: String): LongColumn!

  """Return column with optional projection."""
  camelId(add: String, subtract: String, multiply: String, minimum: String, maximum: String): LongColumn!
}

"""Date (isoformat)"""
scalar Date

"""column of dates"""
type DateColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Date, notEqual: Date, less: Date, lessEqual: Date, greater: Date, greaterEqual: Date, isIn: [Date!]): Long!

  """list of values"""
  values: [Date]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Date]!

  """minimum value"""
  min: Date

  """maximum value"""
  max: Date

  """unique values and counts"""
  unique: DateSet!

  """Return values with null elements replaced."""
  fillNull(value: Date!): DateColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: Date!): DateColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Date!): DateColumn!
}

"""predicates for dates"""
input DateFilter {
  equal: Date
  notEqual: Date
  less: Date
  lessEqual: Date
  greater: Date
  greaterEqual: Date
  isIn: [Date!]
  project: Ordinal
}

"""unique dates"""
type DateSet {
  counts: [Long!]!

  """number of rows"""
  length: Long!

  """list of values"""
  values: [Date]!
}

"""Date with time (isoformat)"""
scalar DateTime

"""column of datetimes"""
type DateTimeColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: DateTime, notEqual: DateTime, less: DateTime, lessEqual: DateTime, greater: DateTime, greaterEqual: DateTime, isIn: [DateTime!]): Long!

  """list of values"""
  values: [DateTime]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [DateTime]!

  """minimum value"""
  min: DateTime

  """maximum value"""
  max: DateTime

  """Return values with null elements replaced."""
  fillNull(value: DateTime!): DateTimeColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: DateTime!): DateTimeColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: DateTime!): DateTimeColumn!
}

"""predicates for datetimes"""
input DateTimeFilter {
  equal: DateTime
  notEqual: DateTime
  less: DateTime
  lessEqual: DateTime
  greater: DateTime
  greaterEqual: DateTime
  isIn: [DateTime!]
  project: Ordinal
}

"""Decimal (fixed-point)"""
scalar Decimal

"""column of decimals"""
type DecimalColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Decimal, notEqual: Decimal, less: Decimal, lessEqual: Decimal, greater: Decimal, greaterEqual: Decimal, isIn: [Decimal!]): Long!

  """list of values"""
  values: [Decimal]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Decimal]!

  """minimum value"""
  min: Decimal

  """maximum value"""
  max: Decimal

  """Return element-wise minimum compared to scalar."""
  minimum(value: Decimal!): DecimalColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Decimal!): DecimalColumn!
}

"""predicates for decimals"""
input DecimalFilter {
  equal: Decimal
  notEqual: Decimal
  less: Decimal
  lessEqual: Decimal
  greater: Decimal
  greaterEqual: Decimal
  isIn: [Decimal!]
  project: Ordinal
}

"""predicates for each column"""
input Filters {
  bool: BooleanFilter
  uint8: IntFilter
  int8: IntFilter
  uint16: IntFilter
  int16: IntFilter
  uint32: LongFilter
  int32: IntFilter
  uint64: LongFilter
  int64: LongFilter
  float: FloatFilter
  double: FloatFilter
  decimal: DecimalFilter
  date32: DateFilter
  date64: DateFilter
  timestamp: DateTimeFilter
  time32: TimeFilter
  time64: TimeFilter
  binary: BinaryFilter
  string: StringFilter
  snakeId: LongFilter
  camelId: LongFilter
}

"""column of floats"""
type FloatColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Float, notEqual: Float, less: Float, lessEqual: Float, greater: Float, greaterEqual: Float, isIn: [Float!]): Long!

  """list of values"""
  values: [Float]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Float]!

  """Return sum of the values, with optional exponentiation."""
  sum(exp: Int! = 1): Float

  """mean of the values"""
  mean: Float

  """minimum value"""
  min: Float

  """maximum value"""
  max: Float

  """Return q-th quantiles for values."""
  quantile(q: [Float!]!): [Float!]!

  """Return values with null elements replaced."""
  fillNull(value: Float!): FloatColumn!

  """Return values added to scalar."""
  add(value: Float!): FloatColumn!

  """Return values subtracted *from* scalar."""
  subtract(value: Float!): FloatColumn!

  """Return values multiplied by scalar."""
  multiply(value: Float!): FloatColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: Float!): FloatColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Float!): FloatColumn!
}

"""predicates for floats"""
input FloatFilter {
  equal: Float
  notEqual: Float
  less: Float
  lessEqual: Float
  greater: Float
  greaterEqual: Float
  isIn: [Float!]
  project: Ratio
}

"""a table sorted by a composite index"""
type IndexedTable {
  """indexed columns"""
  index: [String!]!

  """
  Return table with matching values for compound `index`.
          Queries must be a prefix of the `index`.
          Only one non-equal query is allowed, and applied last.
          
  """
  search(snakeId: LongQuery, camelId: LongQuery): Table!

  """number of rows"""
  length: Long!

  """fields for each column"""
  columns: Columns!

  """Return scalar values at index."""
  row(index: Long! = 0): Row!

  """Return table slice."""
  slice(offset: Long! = 0, length: Long): Table!

  """Return tables grouped by columns, with stable ordering."""
  group(by: [String!]!, reverse: Boolean! = false, length: Long): [Table!]!

  """
  Return table of first or last occurrences grouped by columns, with stable ordering.
  """
  unique(by: [String!]!, reverse: Boolean! = false): Table!

  """
  Return table slice sorted by specified columns.
          Optimized for a single column with fixed length.
          
  """
  sort(by: [String!]!, reverse: Boolean! = false, length: Long): Table!

  """Return table with minimum values per column."""
  min(by: [String!]!): Table!

  """Return table with maximum values per column."""
  max(by: [String!]!): Table!

  """Return table with rows which match all (by default) queries."""
  filter(query: Filters!, invert: Boolean! = false, reduce: Operator! = AND): Table!
}

"""column of ints"""
type IntColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Int, notEqual: Int, less: Int, lessEqual: Int, greater: Int, greaterEqual: Int, isIn: [Int!]): Long!

  """list of values"""
  values: [Int]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Int]!

  """Return sum of the values, with optional exponentiation."""
  sum(exp: Int! = 1): Int

  """mean of the values"""
  mean: Float

  """minimum value"""
  min: Int

  """maximum value"""
  max: Int

  """Return q-th quantiles for values."""
  quantile(q: [Float!]!): [Float!]!

  """unique values and counts"""
  unique: IntSet!

  """Return values with null elements replaced."""
  fillNull(value: Int!): IntColumn!

  """Return values added to scalar."""
  add(value: Int!): IntColumn!

  """Return values subtracted *from* scalar."""
  subtract(value: Int!): IntColumn!

  """Return values multiplied by scalar."""
  multiply(value: Int!): IntColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: Int!): IntColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Int!): IntColumn!
}

"""predicates for ints"""
input IntFilter {
  equal: Int
  notEqual: Int
  less: Int
  lessEqual: Int
  greater: Int
  greaterEqual: Int
  isIn: [Int!]
  project: Ratio
}

"""predicates for ints"""
input IntQuery {
  equal: Int
  notEqual: Int
  less: Int
  lessEqual: Int
  greater: Int
  greaterEqual: Int
  isIn: [Int!]
}

"""unique ints"""
type IntSet {
  counts: [Long!]!

  """number of rows"""
  length: Long!

  """list of values"""
  values: [Int]!
}

"""64-bit int"""
scalar Long

"""column of longs"""
type LongColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Long, notEqual: Long, less: Long, lessEqual: Long, greater: Long, greaterEqual: Long, isIn: [Long!]): Long!

  """list of values"""
  values: [Long]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Long]!

  """Return sum of the values, with optional exponentiation."""
  sum(exp: Int! = 1): Long

  """mean of the values"""
  mean: Float

  """minimum value"""
  min: Long

  """maximum value"""
  max: Long

  """Return q-th quantiles for values."""
  quantile(q: [Float!]!): [Float!]!

  """unique values and counts"""
  unique: LongSet!

  """Return values with null elements replaced."""
  fillNull(value: Long!): LongColumn!

  """Return values added to scalar."""
  add(value: Long!): LongColumn!

  """Return values subtracted *from* scalar."""
  subtract(value: Long!): LongColumn!

  """Return values multiplied by scalar."""
  multiply(value: Long!): LongColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: Long!): LongColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Long!): LongColumn!
}

"""predicates for longs"""
input LongFilter {
  equal: Long
  notEqual: Long
  less: Long
  lessEqual: Long
  greater: Long
  greaterEqual: Long
  isIn: [Long!]
  project: Ratio
}

"""predicates for longs"""
input LongQuery {
  equal: Long
  notEqual: Long
  less: Long
  lessEqual: Long
  greater: Long
  greaterEqual: Long
  isIn: [Long!]
}

"""unique longs"""
type LongSet {
  counts: [Long!]!

  """number of rows"""
  length: Long!

  """list of values"""
  values: [Long]!
}

"""nominal predicates projected across two columns"""
input Nominal {
  equal: String
  notEqual: String
}

enum Operator {
  AND
  OR
  XOR
}

"""ordinal predicates projected across two columns"""
input Ordinal {
  equal: String
  notEqual: String
  less: String
  lessEqual: String
  greater: String
  greaterEqual: String
  minimum: String
  maximum: String
}

"""ratio predicates projected across two columns"""
input Ratio {
  equal: String
  notEqual: String
  less: String
  lessEqual: String
  greater: String
  greaterEqual: String
  minimum: String
  maximum: String
  add: String
  subtract: String
  multiply: String
}

"""scalar fields"""
type Row {
  bool: Boolean
  uint8: Int
  int8: Int
  uint16: Int
  int16: Int
  uint32: Long
  int32: Int
  uint64: Long
  int64: Long
  float: Float
  double: Float
  decimal: Decimal
  date32: Date
  date64: Date
  timestamp: DateTime
  time32: Time
  time64: Time
  binary: Binary
  string: String
  snakeId: Long
  camelId: Long
}

"""column of strings"""
type StringColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: String, notEqual: String, less: String, lessEqual: String, greater: String, greaterEqual: String, isIn: [String!], matchSubstring: String, binaryLength: IntQuery, utf8Lower: StringFilter, utf8Upper: StringFilter, stringIsAscii: Boolean! = false, utf8IsAlnum: Boolean! = false, utf8IsAlpha: Boolean! = false, utf8IsDigit: Boolean! = false, utf8IsLower: Boolean! = false, utf8IsTitle: Boolean! = false, utf8IsUpper: Boolean! = false): Long!

  """list of values"""
  values: [String]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [String]!

  """minimum value"""
  min: String

  """maximum value"""
  max: String

  """unique values and counts"""
  unique: StringSet!

  """length of bytes or strings"""
  binaryLength: IntColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: String!): StringColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: String!): StringColumn!

  """strings converted to lowercase"""
  utf8Lower: StringColumn!

  """strings converted to uppercase"""
  utf8Upper: StringColumn!
}

"""predicates for strings"""
input StringFilter {
  equal: String
  notEqual: String
  less: String
  lessEqual: String
  greater: String
  greaterEqual: String
  isIn: [String!]
  matchSubstring: String
  binaryLength: IntQuery
  utf8Lower: StringFilter
  utf8Upper: StringFilter
  stringIsAscii: Boolean! = false
  utf8IsAlnum: Boolean! = false
  utf8IsAlpha: Boolean! = false
  utf8IsDigit: Boolean! = false
  utf8IsLower: Boolean! = false
  utf8IsTitle: Boolean! = false
  utf8IsUpper: Boolean! = false
  project: Ordinal
}

"""unique strings"""
type StringSet {
  counts: [Long!]!

  """number of rows"""
  length: Long!

  """list of values"""
  values: [String]!
}

"""a column-oriented table"""
type Table {
  """number of rows"""
  length: Long!

  """fields for each column"""
  columns: Columns!

  """Return scalar values at index."""
  row(index: Long! = 0): Row!

  """Return table slice."""
  slice(offset: Long! = 0, length: Long): Table!

  """Return tables grouped by columns, with stable ordering."""
  group(by: [String!]!, reverse: Boolean! = false, length: Long): [Table!]!

  """
  Return table of first or last occurrences grouped by columns, with stable ordering.
  """
  unique(by: [String!]!, reverse: Boolean! = false): Table!

  """
  Return table slice sorted by specified columns.
          Optimized for a single column with fixed length.
          
  """
  sort(by: [String!]!, reverse: Boolean! = false, length: Long): Table!

  """Return table with minimum values per column."""
  min(by: [String!]!): Table!

  """Return table with maximum values per column."""
  max(by: [String!]!): Table!

  """Return table with rows which match all (by default) queries."""
  filter(query: Filters!, invert: Boolean! = false, reduce: Operator! = AND): Table!
}

"""Time (isoformat)"""
scalar Time

"""column of times"""
type TimeColumn {
  """
  Return number of matching values.
  Optimized for `null`, and empty queries will attempt boolean conversion.
  """
  count(equal: Time, notEqual: Time, less: Time, lessEqual: Time, greater: Time, greaterEqual: Time, isIn: [Time!]): Long!

  """list of values"""
  values: [Time]!

  """Return sorted values. Optimized for fixed length."""
  sort(reverse: Boolean! = false, length: Long): [Time]!

  """minimum value"""
  min: Time

  """maximum value"""
  max: Time

  """Return values with null elements replaced."""
  fillNull(value: Time!): TimeColumn!

  """Return element-wise minimum compared to scalar."""
  minimum(value: Time!): TimeColumn!

  """Return element-wise maximum compared to scalar."""
  maximum(value: Time!): TimeColumn!
}

"""predicates for times"""
input TimeFilter {
  equal: Time
  notEqual: Time
  less: Time
  lessEqual: Time
  greater: Time
  greaterEqual: Time
  isIn: [Time!]
  project: Ordinal
}